{
  "version": 3,
  "sources": ["../../src/cubing/puzzles/stickerings/mask.ts", "../../src/cubing/puzzles/stickerings/puzzle-stickerings.ts", "../../src/cubing/puzzles/stickerings/cube-like-stickerings.ts", "../../src/cubing/puzzles/async/lazy-cached.ts", "../../src/cubing/vendor/p-lazy/p-lazy.ts", "../../src/cubing/puzzles/async/async-pg3d.ts", "../../src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts", "../../src/cubing/puzzles/PuzzleLoader.ts", "../../src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts", "../../src/cubing/puzzles/customPGPuzzleLoader.ts", "../../src/cubing/puzzles/cubing-private/index.ts", "../../src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts"],
  "sourcesContent": ["// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const [orbitName, orbitDef] of Object.entries(\n      kpuzzle.definition.orbits,\n    )) {\n      this.stickerings.set(\n        orbitName,\n        new Array(orbitDef.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible], // TODO: 4th entry is for void cube. Should be handled properly for all stickerings.\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      pieceLoop: for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitName)![i] =\n          !pieceSet.stickerings.get(orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const [orbitName, orbitDef] of Object.entries(\n      this.kpuzzle.definition.orbits,\n    )) {\n      for (let i = 0; i < orbitDef.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitName].permutation[i] !== i ||\n          transformation.transformationData[orbitName].orientation[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName in this.kpuzzle.definition.orbits) {\n      if (orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const [orbitName, orbitDef] of Object.entries(this.def.orbits)) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDef.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n", "import type { PuzzleID } from \"../../twisty\";\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\" } }, // default\n  OLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  PLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  LL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  EOLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  COLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  OCLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  CLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  ELL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  ZBLL: { groups: { \"3x3x3\": \"Last Layer\" } },\n  LS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  ELS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  CLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  ZBLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  VLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  WVLS: { groups: { \"3x3x3\": \"Last Slot\" } },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  PieceSet,\n  PieceStickering,\n  StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\n// TODO: cache calculations?\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // For PG\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function cubeStickerings(): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups && \"3x3x3\" in info.groups) {\n      stickerings.push(name);\n    }\n  }\n  return stickerings;\n}\n", "export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n", "// @ts-nocheck\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport {\n  cubeLikeStickeringMask,\n  cubeStickerings,\n} from \"../stickerings/cube-like-stickerings\";\nimport { getCached } from \"./lazy-cached\";\nimport { Move, PuzzleSpecificSimplifyOptions, QuantumMove } from \"../../alg\";\nimport { PLazy } from \"../../vendor/p-lazy/p-lazy\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = cubeStickerings;\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      console.log(kpuzzle);\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n", "import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: {\n    EDGES: { numPieces: 12, numOrientations: 2 },\n    CORNERS: { numPieces: 8, numOrientations: 3 },\n    CENTERS: { numPieces: 6, numOrientations: 4 },\n  },\n  startStateData: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientation: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientation: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientation: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientation: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientation: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientation: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientation: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientation: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientation: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientation: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientation: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientation: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n};\n\ncube3x3x3KPuzzleDefinition.experimentalDerivedMoves = {\n  Uw: \"u\",\n  Lw: \"l\",\n  Fw: \"f\",\n  Rw: \"r\",\n  Bw: \"b\",\n  Dw: \"d\",\n\n  Uv: \"y\",\n  Lv: \"x'\",\n  Fv: \"z\",\n  Rv: \"x\",\n  Bv: \"z'\",\n  Dv: \"y'\",\n\n  \"2U\": \"u U'\",\n  \"2L\": \"l L'\",\n  \"2F\": \"f F'\",\n  \"2R\": \"r R'\",\n  \"2B\": \"b B'\",\n  \"2D\": \"d D'\",\n};\n", "import type { PuzzleSpecificSimplifyOptions } from \"../alg\";\nimport type { AppendOptions } from \"../alg/simplify\";\nimport type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../twisty\";\nimport type { StickeringMask } from \"./stickerings/mask\";\n\nexport interface PuzzleLoader {\n  id: string;\n  // shortName?: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number; // TODO: date?\n  /** @deprecated */\n  def?: never;\n  kpuzzle: () => Promise<KPuzzle>; // TODO\n  svg: () => Promise<string>;\n  llSVG?: () => Promise<string>;\n  pg?: () => Promise<PuzzleGeometry>;\n  stickeringMask?: (\n    stickering: ExperimentalStickering,\n  ) => Promise<StickeringMask>;\n  stickerings?: () => Promise<ExperimentalStickering[]>;\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  puzzleSpecificSimplifyOptionsPromise?: Promise<PuzzleSpecificSimplifyOptions>; // TODO\n}\n\n// TODO: consolidate the `puzzleSpecificSimplifyOptionsPromise` with `puzzleSpecificSimplifyOptions` somehow, so that we don't have to do this.\nexport async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(\n  puzzleLoader: PuzzleLoader,\n): Promise<AppendOptions> {\n  const puzzleSpecificSimplifyOptions =\n    await (puzzleLoader.puzzleSpecificSimplifyOptions ??\n      puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n", "import { Alg } from \"../../../../alg\";\nimport type { KPuzzle, KState, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(state: KState): number {\n  const inverse = state.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientation[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKState());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(state: KState): {\n  normalizedState: KState;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(state);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(state.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedState: state.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize2x2x2Orientation(state).normalizedState;\n  }\n  return !!state.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import { KPuzzle, KPuzzleDefinition } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport { puzzleSpecificSimplifyOptionsPromise } from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: dedup with `cubing/puzzles`\nexport async function asyncGetKPuzzle(\n  desc: PuzzleDescriptionString,\n): Promise<KPuzzle> {\n  const pg = await descAsyncGetPuzzleGeometry(desc);\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = `description: ${desc}`;\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(kpuzzleDefinition, {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzle(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n", "import { KPuzzle } from \"../../kpuzzle\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { getPartialAppendOptionsForPuzzleSpecificSimplifyOptions } from \"../PuzzleLoader\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsStateSolved =\n  experimentalIs3x3x3Solved;\n\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\n\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport { getFaceletStickeringMask as experimentalGetFaceletStickeringMask } from \"../stickerings/mask\";\nexport type {\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\n", "import { Alg } from \"../../../../alg\";\nimport { KState, KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(state: KState): [number, number] {\n  const idxU = state.stateData[\"CENTERS\"].pieces[0];\n  const idxD = state.stateData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = state.stateData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKState(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(state: KState): KState {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return state.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  state: KState,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    state = normalize3x3x3Orientation(state);\n  }\n  if (options.ignoreCenterOrientation) {\n    state = new KState(state.kpuzzle, {\n      EDGES: state.stateData.EDGES,\n      CORNERS: state.stateData.CORNERS,\n      CENTERS: {\n        pieces: state.stateData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!state.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n"],
  "mappings": "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",
  "names": ["pieceStickerings", "asyncGetKPuzzle", "puzzleOrientationCacheRaw", "puzzleOrientationCacheInitialized"]
}
