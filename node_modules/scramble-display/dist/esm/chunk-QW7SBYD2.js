import {
  Alg,
  Move,
  QuantumMove,
  TraversalDownUp,
  functionFromTraversal
} from "./chunk-GNK42KOL.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper
} from "./chunk-S5HBEHAC.js";

// node_modules/cubing/dist/esm/chunk-AUF56UEH.js
function combineTransformationData(definition, transformationData1, transformationData2) {
  const newTransformationData = {};
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const orbit1 = transformationData1[orbitName];
    const orbit2 = transformationData2[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {
      newTransformationData[orbitName] = orbit1;
    } else if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit1)) {
      newTransformationData[orbitName] = orbit2;
    } else {
      const newPerm = new Array(orbitDefinition.numPieces);
      if (orbitDefinition.numOrientations === 1) {
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];
        }
        newTransformationData[orbitName] = {
          permutation: newPerm,
          orientation: orbit1.orientation
        };
      } else {
        const newOri = new Array(orbitDefinition.numPieces);
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;
          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];
        }
        newTransformationData[orbitName] = {
          permutation: newPerm,
          orientation: newOri
        };
      }
    }
  }
  return newTransformationData;
}
function applyTransformationDataToStateData(definition, stateData, transformationData) {
  const newStateData = {};
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const orbit1 = stateData[orbitName];
    const orbit2 = transformationData[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {
      newStateData[orbitName] = orbit1;
    } else {
      const newPieces = new Array(orbitDefinition.numPieces);
      if (orbitDefinition.numOrientations === 1) {
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];
        }
        newStateData[orbitName] = {
          pieces: newPieces,
          orientation: orbit1.orientation
        };
      } else {
        const newOri = new Array(orbitDefinition.numPieces);
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;
          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];
        }
        newStateData[orbitName] = {
          pieces: newPieces,
          orientation: newOri
        };
      }
    }
  }
  return newStateData;
}
var FREEZE = false;
var identityOrbitCache = /* @__PURE__ */ new Map();
function constructIdentityOrbitTransformation(numPieces) {
  const cached = identityOrbitCache.get(numPieces);
  if (cached) {
    return cached;
  }
  const newPermutation = new Array(numPieces);
  const newOrientation = new Array(numPieces);
  for (let i = 0; i < numPieces; i++) {
    newPermutation[i] = i;
    newOrientation[i] = 0;
  }
  const orbitTransformation = {
    permutation: newPermutation,
    orientation: newOrientation
  };
  if (FREEZE) {
    Object.freeze(newPermutation);
    Object.freeze(newOrientation);
    Object.freeze(orbitTransformation);
  }
  identityOrbitCache.set(numPieces, orbitTransformation);
  return orbitTransformation;
}
function constructIdentityTransformationDataUncached(definition) {
  const transformation = {};
  for (const [orbitName, orbitDefinition] of Object.entries(definition.orbits)) {
    transformation[orbitName] = constructIdentityOrbitTransformation(orbitDefinition.numPieces);
  }
  if (FREEZE) {
    Object.freeze(transformation);
  }
  return transformation;
}
function moveToTransformationUncached(kpuzzle, move) {
  const quantumKey = move.quantum.toString();
  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey];
  if (!quantumMoveDefinition) {
    const derivedFrom = kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];
    if (derivedFrom) {
      quantumMoveDefinition = kpuzzle.algToTransformation(derivedFrom).transformationData;
    }
  }
  if (quantumMoveDefinition) {
    return repeatTransformationUncached(kpuzzle, quantumMoveDefinition, move.amount);
  }
  const moveDefinition = kpuzzle.definition.moves[move.toString()];
  if (moveDefinition) {
    return moveDefinition;
  }
  const inverseMoveDefinition = kpuzzle.definition.moves[move.invert().toString()];
  if (inverseMoveDefinition) {
    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);
  }
  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);
}
var KState = class {
  constructor(kpuzzle, stateData) {
    this.kpuzzle = kpuzzle;
    this.stateData = stateData;
  }
  toJSON() {
    return {
      experimentalPuzzleName: this.kpuzzle.name(),
      stateData: this.stateData
    };
  }
  static fromTransformation(transformation) {
    const newStateData = applyTransformationDataToStateData(transformation.kpuzzle.definition, transformation.kpuzzle.definition.startStateData, transformation.transformationData);
    return new KState(transformation.kpuzzle, newStateData);
  }
  apply(source) {
    return this.applyTransformation(this.kpuzzle.toTransformation(source));
  }
  applyTransformation(transformation) {
    if (transformation.isIdentityTransformation()) {
      return new KState(this.kpuzzle, this.stateData);
    }
    const newStateData = applyTransformationDataToStateData(this.kpuzzle.definition, this.stateData, transformation.transformationData);
    return new KState(this.kpuzzle, newStateData);
  }
  applyMove(move) {
    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));
  }
  applyAlg(alg) {
    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));
  }
  experimentalToTransformation() {
    if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {
      return null;
    }
    const transformationData = {};
    for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {
      const transformationOrbit = {
        permutation: stateOrbitData.pieces,
        orientation: stateOrbitData.orientation
      };
      transformationData[orbitName] = transformationOrbit;
    }
    return new KTransformation(this.kpuzzle, transformationData);
  }
  experimentalIsSolved(options) {
    if (!this.kpuzzle.definition.experimentalIsStateSolved) {
      throw new Error("`KState.experimentalIsSolved()` is not supported for this puzzle at the moment.");
    }
    return this.kpuzzle.definition.experimentalIsStateSolved(this, options);
  }
};
var _cachedIsIdentity, _a;
var KTransformation = (_a = class {
  constructor(kpuzzle, transformationData) {
    __privateAdd(this, _cachedIsIdentity, void 0);
    this.kpuzzle = kpuzzle;
    this.transformationData = transformationData;
  }
  toJSON() {
    return {
      experimentalPuzzleName: this.kpuzzle.name(),
      transformationData: this.transformationData
    };
  }
  invert() {
    return new KTransformation(this.kpuzzle, invertTransformation(this.kpuzzle, this.transformationData));
  }
  isIdentityTransformation() {
    return __privateGet(this, _cachedIsIdentity) ?? __privateSet(this, _cachedIsIdentity, this.isIdentical(this.kpuzzle.identityTransformation()));
  }
  static experimentalConstructIdentity(kpuzzle) {
    const transformation = new KTransformation(kpuzzle, constructIdentityTransformationDataUncached(kpuzzle.definition));
    __privateSet(transformation, _cachedIsIdentity, true);
    return transformation;
  }
  isIdentical(t2) {
    return isTransformationDataIdentical(this.kpuzzle, this.transformationData, t2.transformationData);
  }
  apply(source) {
    return this.applyTransformation(this.kpuzzle.toTransformation(source));
  }
  applyTransformation(t2) {
    if (this.kpuzzle !== t2.kpuzzle) {
      throw new Error(`Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`);
    }
    if (__privateGet(this, _cachedIsIdentity)) {
      return new KTransformation(this.kpuzzle, t2.transformationData);
    }
    if (__privateGet(t2, _cachedIsIdentity)) {
      return new KTransformation(this.kpuzzle, this.transformationData);
    }
    return new KTransformation(this.kpuzzle, combineTransformationData(this.kpuzzle.definition, this.transformationData, t2.transformationData));
  }
  applyMove(move) {
    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));
  }
  applyAlg(alg) {
    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));
  }
  toKState() {
    return KState.fromTransformation(this);
  }
  repetitionOrder() {
    return transformationRepetitionOrder(this.kpuzzle.definition, this);
  }
  selfMultiply(amount) {
    return new KTransformation(this.kpuzzle, repeatTransformationUncached(this.kpuzzle, this.transformationData, amount));
  }
}, _cachedIsIdentity = new WeakMap(), _a);
function isOrbitTransformationDataIdentityUncached(numOrientations, orbitTransformationData) {
  const { permutation } = orbitTransformationData;
  const numPieces = permutation.length;
  for (let idx = 0; idx < numPieces; idx++) {
    if (permutation[idx] !== idx) {
      return false;
    }
  }
  if (numOrientations > 1) {
    const { orientation } = orbitTransformationData;
    for (let idx = 0; idx < numPieces; idx++) {
      if (orientation[idx] !== 0) {
        return false;
      }
    }
  }
  return true;
}
function isOrbitTransformationDataIdentical(orbitDefinition, orbitTransformationData1, orbitTransformationData2, options = {}) {
  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
    if (!options?.ignoreOrientation && orbitTransformationData1.orientation[idx] !== orbitTransformationData2.orientation[idx]) {
      return false;
    }
    if (!options?.ignorePermutation && orbitTransformationData1.permutation[idx] !== orbitTransformationData2.permutation[idx]) {
      return false;
    }
  }
  return true;
}
function isTransformationDataIdentical(kpuzzle, transformationData1, transformationData2) {
  for (const [orbitName, orbitDefinition] of Object.entries(kpuzzle.definition.orbits)) {
    if (!isOrbitTransformationDataIdentical(orbitDefinition, transformationData1[orbitName], transformationData2[orbitName])) {
      return false;
    }
  }
  return true;
}
function invertTransformation(kpuzzle, transformationData) {
  const newTransformationData = {};
  for (const orbitName in kpuzzle.definition.orbits) {
    const orbitDefinition = kpuzzle.definition.orbits[orbitName];
    const orbitTransformationData = transformationData[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbitTransformationData)) {
      newTransformationData[orbitName] = orbitTransformationData;
    } else if (orbitDefinition.numOrientations === 1) {
      const newPerm = new Array(orbitDefinition.numPieces);
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        newPerm[orbitTransformationData.permutation[idx]] = idx;
      }
      newTransformationData[orbitName] = {
        permutation: newPerm,
        orientation: orbitTransformationData.orientation
      };
    } else {
      const newPerm = new Array(orbitDefinition.numPieces);
      const newOri = new Array(orbitDefinition.numPieces);
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        const fromIdx = orbitTransformationData.permutation[idx];
        newPerm[fromIdx] = idx;
        newOri[fromIdx] = (orbitDefinition.numOrientations - orbitTransformationData.orientation[idx] + orbitDefinition.numOrientations) % orbitDefinition.numOrientations;
      }
      newTransformationData[orbitName] = {
        permutation: newPerm,
        orientation: newOri
      };
    }
  }
  return newTransformationData;
}
function repeatTransformationUncached(kpuzzle, transformationData, amount) {
  if (amount === 1) {
    return transformationData;
  }
  if (amount < 0) {
    return repeatTransformationUncached(kpuzzle, invertTransformation(kpuzzle, transformationData), -amount);
  }
  if (amount === 0) {
    const { transformationData: transformationData2 } = kpuzzle.identityTransformation();
    return transformationData2;
  }
  let halfish = transformationData;
  if (amount !== 2) {
    halfish = repeatTransformationUncached(kpuzzle, transformationData, Math.floor(amount / 2));
  }
  const twiceHalfish = combineTransformationData(kpuzzle.definition, halfish, halfish);
  if (amount % 2 === 0) {
    return twiceHalfish;
  } else {
    return combineTransformationData(kpuzzle.definition, transformationData, twiceHalfish);
  }
}
var AlgToTransformationTraversal = class extends TraversalDownUp {
  traverseAlg(alg, kpuzzle) {
    let transformation = null;
    for (const algNode of alg.childAlgNodes()) {
      if (transformation) {
        transformation = transformation.applyTransformation(this.traverseAlgNode(algNode, kpuzzle));
      } else {
        transformation = this.traverseAlgNode(algNode, kpuzzle);
      }
    }
    return transformation ?? kpuzzle.identityTransformation();
  }
  traverseGrouping(grouping, kpuzzle) {
    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);
    return new KTransformation(kpuzzle, repeatTransformationUncached(kpuzzle, algTransformation.transformationData, grouping.amount));
  }
  traverseMove(move, kpuzzle) {
    return kpuzzle.moveToTransformation(move);
  }
  traverseCommutator(commutator, kpuzzle) {
    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);
    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);
    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert()).applyTransformation(bTransformation.invert());
  }
  traverseConjugate(conjugate, kpuzzle) {
    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);
    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);
    return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert());
  }
  traversePause(_, kpuzzle) {
    return kpuzzle.identityTransformation();
  }
  traverseNewline(_, kpuzzle) {
    return kpuzzle.identityTransformation();
  }
  traverseLineComment(_, kpuzzle) {
    return kpuzzle.identityTransformation();
  }
};
var algToTransformation = functionFromTraversal(AlgToTransformationTraversal);
function gcd(a, b) {
  if (b) {
    return gcd(b, a % b);
  }
  return a;
}
function transformationRepetitionOrder(definition, transformation) {
  let order = 1;
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const transformationOrbit = transformation.transformationData[orbitName];
    const orbitPieces = new Array(orbitDefinition.numPieces);
    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {
      if (!orbitPieces[startIdx]) {
        let currentIdx = startIdx;
        let orientationSum = 0;
        let cycleLength = 0;
        for (; ; ) {
          orbitPieces[currentIdx] = true;
          orientationSum = orientationSum + transformationOrbit.orientation[currentIdx];
          cycleLength = cycleLength + 1;
          currentIdx = transformationOrbit.permutation[currentIdx];
          if (currentIdx === startIdx) {
            break;
          }
        }
        if (orientationSum !== 0) {
          cycleLength = cycleLength * orbitDefinition.numOrientations / gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));
        }
        order = order * cycleLength / gcd(order, cycleLength);
      }
    }
  }
  return order;
}
var _moveToTransformationDataCache, _cachedCanConvertStateToUniqueTransformation, _a2;
var KPuzzle = (_a2 = class {
  constructor(definition, options) {
    __privateAdd(this, _moveToTransformationDataCache, void 0);
    __privateAdd(this, _cachedCanConvertStateToUniqueTransformation, void 0);
    this.definition = definition;
    __privateSet(this, _moveToTransformationDataCache, /* @__PURE__ */ new Map());
    this.experimentalPGNotation = options?.experimentalPGNotation;
  }
  name() {
    return this.definition.name;
  }
  identityTransformation() {
    return KTransformation.experimentalConstructIdentity(this);
  }
  moveToTransformation(move) {
    if (typeof move === "string") {
      move = new Move(move);
    }
    const cacheKey = move.toString();
    const cachedTransformationData = __privateGet(this, _moveToTransformationDataCache).get(cacheKey);
    if (cachedTransformationData) {
      return new KTransformation(this, cachedTransformationData);
    }
    if (this.experimentalPGNotation) {
      const transformationData2 = this.experimentalPGNotation.lookupMove(move);
      if (!transformationData2) {
        throw new Error(`could not map to internal move: ${move}`);
      }
      __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData2);
      return new KTransformation(this, transformationData2);
    }
    const transformationData = moveToTransformationUncached(this, move);
    __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData);
    return new KTransformation(this, transformationData);
  }
  algToTransformation(alg) {
    if (typeof alg === "string") {
      alg = new Alg(alg);
    }
    return algToTransformation(alg, this);
  }
  toTransformation(source) {
    if (typeof source === "string") {
      return this.algToTransformation(source);
    } else if (source?.is?.(Alg)) {
      return this.algToTransformation(source);
    } else if (source?.is?.(Move)) {
      return this.moveToTransformation(source);
    } else {
      return source;
    }
  }
  startState() {
    return new KState(this, this.definition.startStateData);
  }
  canConvertStateToUniqueTransformation() {
    return __privateGet(this, _cachedCanConvertStateToUniqueTransformation) ?? __privateSet(this, _cachedCanConvertStateToUniqueTransformation, (() => {
      for (const [orbitName, orbitDefinition] of Object.entries(this.definition.orbits)) {
        const pieces = new Array(orbitDefinition.numPieces).fill(false);
        for (const piece of this.definition.startStateData[orbitName].pieces) {
          pieces[piece] = true;
        }
        for (const piece of pieces) {
          if (!piece) {
            return false;
          }
        }
      }
      return true;
    })());
  }
}, _moveToTransformationDataCache = new WeakMap(), _cachedCanConvertStateToUniqueTransformation = new WeakMap(), _a2);

// node_modules/cubing/dist/esm/chunk-WPIG35IN.js
function getFaceletStickeringMask(stickeringMask, orbitName, pieceIdx, faceletIdx, hint) {
  const orbitStickeringMask = stickeringMask.orbits[orbitName];
  const pieceStickeringMask = orbitStickeringMask.pieces[pieceIdx];
  if (pieceStickeringMask === null) {
    return regular;
  }
  const faceletStickeringMask = pieceStickeringMask.facelets?.[faceletIdx];
  if (faceletStickeringMask === null) {
    return regular;
  }
  if (typeof faceletStickeringMask === "string") {
    return faceletStickeringMask;
  }
  if (hint) {
    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;
  }
  console.log(faceletStickeringMask);
  return faceletStickeringMask.mask;
}
var PieceAnnotation = class {
  constructor(kpuzzle, defaultValue) {
    this.stickerings = /* @__PURE__ */ new Map();
    for (const [orbitName, orbitDef] of Object.entries(kpuzzle.definition.orbits)) {
      this.stickerings.set(orbitName, new Array(orbitDef.numPieces).fill(defaultValue));
    }
  }
};
var regular = "regular";
var ignored = "ignored";
var oriented = "oriented";
var invisible = "invisible";
var dim = "dim";
var pieceStickerings = {
  ["Regular"]: {
    facelets: [regular, regular, regular, regular, regular]
  },
  ["Ignored"]: {
    facelets: [ignored, ignored, ignored, ignored, ignored]
  },
  ["OrientationStickers"]: {
    facelets: [oriented, oriented, oriented, oriented, oriented]
  },
  ["IgnoreNonPrimary"]: {
    facelets: [regular, ignored, ignored, ignored, ignored]
  },
  ["Invisible"]: {
    facelets: [invisible, invisible, invisible, invisible]
  },
  ["PermuteNonPrimary"]: {
    facelets: [dim, regular, regular, regular, regular]
  },
  ["Dim"]: {
    facelets: [dim, dim, dim, dim, dim]
  },
  ["Ignoriented"]: {
    facelets: [dim, ignored, ignored, ignored, ignored]
  },
  ["OrientationWithoutPermutation"]: {
    facelets: [oriented, ignored, ignored, ignored, ignored]
  }
};
function getPieceStickeringMask(pieceStickering) {
  return pieceStickerings[pieceStickering];
}
var PuzzleStickering = class extends PieceAnnotation {
  constructor(kpuzzle) {
    super(kpuzzle, "Regular");
  }
  set(pieceSet, pieceStickering) {
    for (const [orbitName, pieces] of this.stickerings.entries()) {
      for (let i = 0; i < pieces.length; i++) {
        if (pieceSet.stickerings.get(orbitName)[i]) {
          pieces[i] = pieceStickering;
        }
      }
    }
    return this;
  }
  toStickeringMask() {
    const stickeringMask = { orbits: {} };
    for (const [orbitName, pieceStickerings2] of this.stickerings.entries()) {
      const pieces = [];
      const orbitStickeringMask = {
        pieces
      };
      stickeringMask.orbits[orbitName] = orbitStickeringMask;
      for (const pieceStickering of pieceStickerings2) {
        pieces.push(getPieceStickeringMask(pieceStickering));
      }
    }
    return stickeringMask;
  }
};
var StickeringManager = class {
  constructor(kpuzzle) {
    this.kpuzzle = kpuzzle;
  }
  and(pieceSets) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      pieceLoop:
        for (let i = 0; i < orbitDef.numPieces; i++) {
          newPieceSet.stickerings.get(orbitName)[i] = true;
          for (const pieceSet of pieceSets) {
            if (!pieceSet.stickerings.get(orbitName)[i]) {
              newPieceSet.stickerings.get(orbitName)[i] = false;
              continue pieceLoop;
            }
          }
        }
    }
    return newPieceSet;
  }
  or(pieceSets) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      pieceLoop:
        for (let i = 0; i < orbitDef.numPieces; i++) {
          newPieceSet.stickerings.get(orbitName)[i] = false;
          for (const pieceSet of pieceSets) {
            if (pieceSet.stickerings.get(orbitName)[i]) {
              newPieceSet.stickerings.get(orbitName)[i] = true;
              continue pieceLoop;
            }
          }
        }
    }
    return newPieceSet;
  }
  not(pieceSet) {
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      for (let i = 0; i < orbitDef.numPieces; i++) {
        newPieceSet.stickerings.get(orbitName)[i] = !pieceSet.stickerings.get(orbitName)[i];
      }
    }
    return newPieceSet;
  }
  all() {
    return this.and(this.moves([]));
  }
  move(moveSource) {
    const transformation = this.kpuzzle.moveToTransformation(moveSource);
    const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
      for (let i = 0; i < orbitDef.numPieces; i++) {
        if (transformation.transformationData[orbitName].permutation[i] !== i || transformation.transformationData[orbitName].orientation[i] !== 0) {
          newPieceSet.stickerings.get(orbitName)[i] = true;
        }
      }
    }
    return newPieceSet;
  }
  moves(moveSources) {
    return moveSources.map((moveSource) => this.move(moveSource));
  }
  orbits(orbitNames) {
    const pieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const orbitName of orbitNames) {
      pieceSet.stickerings.get(orbitName).fill(true);
    }
    return pieceSet;
  }
  orbitPrefix(orbitPrefix) {
    const pieceSet = new PieceAnnotation(this.kpuzzle, false);
    for (const orbitName in this.kpuzzle.definition.orbits) {
      if (orbitName.startsWith(orbitPrefix)) {
        pieceSet.stickerings.get(orbitName).fill(true);
      }
    }
    return pieceSet;
  }
};
var experimentalStickerings = {
  full: { groups: { "3x3x3": "Stickering" } },
  OLL: { groups: { "3x3x3": "Last Layer" } },
  PLL: { groups: { "3x3x3": "Last Layer" } },
  LL: { groups: { "3x3x3": "Last Layer" } },
  EOLL: { groups: { "3x3x3": "Last Layer" } },
  COLL: { groups: { "3x3x3": "Last Layer" } },
  OCLL: { groups: { "3x3x3": "Last Layer" } },
  CLL: { groups: { "3x3x3": "Last Layer" } },
  ELL: { groups: { "3x3x3": "Last Layer" } },
  ZBLL: { groups: { "3x3x3": "Last Layer" } },
  LS: { groups: { "3x3x3": "Last Slot" } },
  ELS: { groups: { "3x3x3": "Last Slot" } },
  CLS: { groups: { "3x3x3": "Last Slot" } },
  ZBLS: { groups: { "3x3x3": "Last Slot" } },
  VLS: { groups: { "3x3x3": "Last Slot" } },
  WVLS: { groups: { "3x3x3": "Last Slot" } },
  F2L: { groups: { "3x3x3": "CFOP (Fridrich)" } },
  Daisy: { groups: { "3x3x3": "CFOP (Fridrich)" } },
  Cross: { groups: { "3x3x3": "CFOP (Fridrich)" } },
  EO: { groups: { "3x3x3": "ZZ" } },
  EOline: { groups: { "3x3x3": "ZZ" } },
  EOcross: { groups: { "3x3x3": "ZZ" } },
  CMLL: { groups: { "3x3x3": "Roux" } },
  L10P: { groups: { "3x3x3": "Roux" } },
  L6E: { groups: { "3x3x3": "Roux" } },
  L6EO: { groups: { "3x3x3": "Roux" } },
  "2x2x2": { groups: { "3x3x3": "Petrus" } },
  "2x2x3": { groups: { "3x3x3": "Petrus" } },
  "Void Cube": { groups: { "3x3x3": "Miscellaneous" } },
  invisible: { groups: { "3x3x3": "Miscellaneous" } },
  picture: { groups: { "3x3x3": "Miscellaneous" } },
  "centers-only": { groups: { "3x3x3": "Miscellaneous" } },
  "experimental-centers-U": {},
  "experimental-centers-U-D": {},
  "experimental-centers-U-L-D": {},
  "experimental-centers-U-L-B-D": {},
  "experimental-centers": {},
  "experimental-fto-fc": { groups: { fto: "Bencisco" } },
  "experimental-fto-f2t": { groups: { fto: "Bencisco" } },
  "experimental-fto-sc": { groups: { fto: "Bencisco" } },
  "experimental-fto-l2c": { groups: { fto: "Bencisco" } },
  "experimental-fto-lbt": { groups: { fto: "Bencisco" } },
  "experimental-fto-l3t": { groups: { fto: "Bencisco" } }
};
async function cubeLikeStickeringMask(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const LL = () => m.move("U");
  const orUD = () => m.or(m.moves(["U", "D"]));
  const orLR = () => m.or(m.moves(["L", "R"]));
  const M = () => m.not(orLR());
  const F2L = () => m.not(LL());
  const CENTERS = () => m.orbitPrefix("CENTER");
  const EDGES = () => m.orbitPrefix("EDGE");
  const CORNERS = () => m.or([
    m.orbitPrefix("CORNER"),
    m.orbitPrefix("C4RNER"),
    m.orbitPrefix("C5RNER")
  ]);
  const L6E = () => m.or([M(), m.and([LL(), EDGES()])]);
  const centerLL = () => m.and([LL(), CENTERS()]);
  const edgeFR = () => m.and([m.and(m.moves(["F", "R"])), EDGES()]);
  const cornerDFR = () => m.and([m.and(m.moves(["F", "R"])), CORNERS(), m.not(LL())]);
  const slotFR = () => m.or([cornerDFR(), edgeFR()]);
  function dimF2L() {
    puzzleStickering.set(F2L(), "Dim");
  }
  function setPLL() {
    puzzleStickering.set(LL(), "PermuteNonPrimary");
    puzzleStickering.set(centerLL(), "Dim");
  }
  function setOLL() {
    puzzleStickering.set(LL(), "IgnoreNonPrimary");
    puzzleStickering.set(centerLL(), "Regular");
  }
  function dimOLL() {
    puzzleStickering.set(LL(), "Ignoriented");
    puzzleStickering.set(centerLL(), "Dim");
  }
  switch (stickering) {
    case "full":
      break;
    case "PLL": {
      dimF2L();
      setPLL();
      break;
    }
    case "CLS": {
      dimF2L();
      puzzleStickering.set(cornerDFR(), "Regular");
      puzzleStickering.set(LL(), "Ignoriented");
      puzzleStickering.set(m.and([LL(), CENTERS()]), "Dim");
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary");
      break;
    }
    case "OLL": {
      dimF2L();
      setOLL();
      break;
    }
    case "EOLL": {
      dimF2L();
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored");
      break;
    }
    case "COLL": {
      dimF2L();
      puzzleStickering.set(m.and([LL(), EDGES()]), "Ignoriented");
      puzzleStickering.set(m.and([LL(), CENTERS()]), "Dim");
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular");
      break;
    }
    case "OCLL": {
      dimF2L();
      dimOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary");
      break;
    }
    case "CLL": {
      dimF2L();
      puzzleStickering.set(m.not(m.and([CORNERS(), LL()])), "Dim");
      break;
    }
    case "ELL": {
      dimF2L();
      puzzleStickering.set(LL(), "Dim");
      puzzleStickering.set(m.and([LL(), EDGES()]), "Regular");
      break;
    }
    case "ELS": {
      dimF2L();
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored");
      puzzleStickering.set(edgeFR(), "Regular");
      puzzleStickering.set(cornerDFR(), "Ignored");
      break;
    }
    case "LL": {
      dimF2L();
      break;
    }
    case "F2L": {
      puzzleStickering.set(LL(), "Ignored");
      break;
    }
    case "ZBLL": {
      dimF2L();
      puzzleStickering.set(LL(), "PermuteNonPrimary");
      puzzleStickering.set(centerLL(), "Dim");
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular");
      break;
    }
    case "ZBLS": {
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular");
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored");
      break;
    }
    case "VLS": {
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular");
      setOLL();
      break;
    }
    case "WVLS": {
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular");
      puzzleStickering.set(m.and([LL(), EDGES()]), "Ignoriented");
      puzzleStickering.set(m.and([LL(), CENTERS()]), "Dim");
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary");
      break;
    }
    case "LS": {
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular");
      puzzleStickering.set(LL(), "Ignored");
      puzzleStickering.set(centerLL(), "Dim");
      break;
    }
    case "EO": {
      puzzleStickering.set(CORNERS(), "Ignored");
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation");
      break;
    }
    case "EOline": {
      puzzleStickering.set(CORNERS(), "Ignored");
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation");
      puzzleStickering.set(m.and(m.moves(["D", "M"])), "Regular");
      break;
    }
    case "EOcross": {
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation");
      puzzleStickering.set(m.move("D"), "Regular");
      puzzleStickering.set(CORNERS(), "Ignored");
      break;
    }
    case "CMLL": {
      puzzleStickering.set(F2L(), "Dim");
      puzzleStickering.set(L6E(), "Ignored");
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular");
      break;
    }
    case "L10P": {
      puzzleStickering.set(m.not(L6E()), "Dim");
      puzzleStickering.set(m.and([CORNERS(), LL()]), "Regular");
      break;
    }
    case "L6E": {
      puzzleStickering.set(m.not(L6E()), "Dim");
      break;
    }
    case "L6EO": {
      puzzleStickering.set(m.not(L6E()), "Dim");
      puzzleStickering.set(L6E(), "OrientationWithoutPermutation");
      puzzleStickering.set(m.and([CENTERS(), orUD()]), "OrientationStickers");
      break;
    }
    case "Daisy": {
      puzzleStickering.set(m.all(), "Ignored");
      puzzleStickering.set(CENTERS(), "Dim");
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular");
      puzzleStickering.set(m.and([m.move("U"), EDGES()]), "IgnoreNonPrimary");
      break;
    }
    case "Cross": {
      puzzleStickering.set(m.all(), "Ignored");
      puzzleStickering.set(CENTERS(), "Dim");
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular");
      puzzleStickering.set(m.and([m.move("D"), EDGES()]), "Regular");
      break;
    }
    case "2x2x2": {
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored");
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim");
      break;
    }
    case "2x2x3": {
      puzzleStickering.set(m.all(), "Dim");
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored");
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim");
      puzzleStickering.set(m.and([m.move("F"), m.not(m.or(m.moves(["U", "R"])))]), "Regular");
      break;
    }
    case "Void Cube": {
      puzzleStickering.set(CENTERS(), "Invisible");
      break;
    }
    case "picture":
    case "invisible": {
      puzzleStickering.set(m.all(), "Invisible");
      break;
    }
    case "centers-only": {
      puzzleStickering.set(m.not(CENTERS()), "Ignored");
      break;
    }
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim");
  }
  return puzzleStickering.toStickeringMask();
}
async function cubeStickerings() {
  const stickerings = [];
  for (const [name, info] of Object.entries(experimentalStickerings)) {
    if (info.groups && "3x3x3" in info.groups) {
      stickerings.push(name);
    }
  }
  return stickerings;
}
function getCached(getValue) {
  let cachedPromise = null;
  return () => {
    return cachedPromise ?? (cachedPromise = getValue());
  };
}
var PLazy = class extends Promise {
  constructor(executor) {
    super((resolve) => {
      resolve();
    });
    this._executor = executor;
  }
  static from(function_) {
    return new PLazy((resolve) => {
      resolve(function_());
    });
  }
  static resolve(value) {
    return new PLazy((resolve) => {
      resolve(value);
    });
  }
  static reject(error) {
    return new PLazy((_resolve, reject) => {
      reject(error);
    });
  }
  then(onFulfilled, onRejected) {
    this._promise = this._promise || new Promise(this._executor);
    return this._promise.then(onFulfilled, onRejected);
  }
  catch(onRejected) {
    this._promise = this._promise || new Promise(this._executor);
    return this._promise.catch(onRejected);
  }
};
function from(function_) {
  return new PLazy((resolve) => {
    resolve(function_());
  });
}
async function asyncGetPuzzleGeometry(puzzleName) {
  const puzzleGeometry = await import("./puzzle-geometry-SH22JMRM.js");
  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle(pgPromise, puzzleName) {
  const pg = await pgPromise;
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = puzzleName;
  const puzzleGeometry = await import("./puzzle-geometry-SH22JMRM.js");
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var _cachedPG, _cachedKPuzzle, _cachedSVG, _a3;
var PGPuzzleLoader = (_a3 = class {
  constructor(info) {
    __privateAdd(this, _cachedPG, void 0);
    __privateAdd(this, _cachedKPuzzle, void 0);
    __privateAdd(this, _cachedSVG, void 0);
    this.puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(this.kpuzzle.bind(this));
    this.pgId = info.pgID;
    this.id = info.id;
    this.fullName = info.fullName;
    this.inventedBy = info.inventedBy;
    this.inventionYear = info.inventionYear;
  }
  pg() {
    return __privateGet(this, _cachedPG) ?? __privateSet(this, _cachedPG, asyncGetPuzzleGeometry(this.pgId ?? this.id));
  }
  kpuzzle() {
    return __privateGet(this, _cachedKPuzzle) ?? __privateSet(this, _cachedKPuzzle, asyncGetKPuzzle(this.pg(), this.id));
  }
  svg() {
    return __privateGet(this, _cachedSVG) ?? __privateSet(this, _cachedSVG, (async () => (await this.pg()).generatesvg())());
  }
}, _cachedPG = new WeakMap(), _cachedKPuzzle = new WeakMap(), _cachedSVG = new WeakMap(), _a3);
var CubePGPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super(...arguments);
    this.stickerings = cubeStickerings;
  }
  stickeringMask(stickering) {
    return cubeLikeStickeringMask(this, stickering);
  }
};
function puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn) {
  return new PLazy(async (resolve) => {
    const kpuzzle = await kpuzzlePromiseFn();
    console.log(kpuzzle);
    resolve({
      quantumMoveOrder: (m) => {
        return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();
      }
    });
  });
}
var cube3x3x3KPuzzleDefinition = {
  name: "3x3x3",
  orbits: {
    EDGES: { numPieces: 12, numOrientations: 2 },
    CORNERS: { numPieces: 8, numOrientations: 3 },
    CENTERS: { numPieces: 6, numOrientations: 4 }
  },
  startStateData: {
    EDGES: {
      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    CORNERS: {
      pieces: [0, 1, 2, 3, 4, 5, 6, 7],
      orientation: [0, 0, 0, 0, 0, 0, 0, 0]
    },
    CENTERS: {
      pieces: [0, 1, 2, 3, 4, 5],
      orientation: [0, 0, 0, 0, 0, 0]
    }
  },
  moves: {
    U: {
      EDGES: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [1, 0, 0, 0, 0, 0]
      }
    },
    y: {
      EDGES: {
        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 7, 4, 5, 6],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 2, 3, 4, 1, 5],
        orientation: [1, 0, 0, 0, 0, 3]
      }
    },
    x: {
      EDGES: {
        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 3, 5, 7, 6, 2, 1],
        orientation: [2, 1, 2, 1, 1, 2, 1, 2]
      },
      CENTERS: {
        permutation: [2, 1, 5, 3, 0, 4],
        orientation: [0, 3, 0, 1, 2, 2]
      }
    },
    L: {
      EDGES: {
        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 6, 2, 4, 3, 5, 7],
        orientation: [0, 0, 2, 1, 0, 2, 1, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 1, 0, 0, 0, 0]
      }
    },
    F: {
      EDGES: {
        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],
        orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0]
      },
      CORNERS: {
        permutation: [3, 1, 2, 5, 0, 4, 6, 7],
        orientation: [1, 0, 0, 2, 2, 1, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 1, 0, 0, 0]
      }
    },
    R: {
      EDGES: {
        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 2, 3, 7, 5, 6, 1],
        orientation: [2, 1, 0, 0, 1, 0, 0, 2]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 1, 0, 0]
      }
    },
    B: {
      EDGES: {
        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],
        orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1]
      },
      CORNERS: {
        permutation: [0, 7, 1, 3, 4, 5, 2, 6],
        orientation: [0, 2, 1, 0, 0, 0, 2, 1]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 0, 1, 0]
      }
    },
    D: {
      EDGES: {
        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 1, 2, 3, 4, 5],
        orientation: [0, 0, 0, 0, 0, 1]
      }
    },
    z: {
      EDGES: {
        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],
        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [3, 2, 6, 5, 0, 4, 7, 1],
        orientation: [1, 2, 1, 2, 2, 1, 2, 1]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 1, 1, 3, 1]
      }
    },
    M: {
      EDGES: {
        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 0, 0, 0, 2, 0]
      }
    },
    E: {
      EDGES: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [0, 0, 0, 0, 0, 0]
      }
    },
    S: {
      EDGES: {
        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],
        orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 0, 1, 0, 1]
      }
    },
    u: {
      EDGES: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [1, 2, 3, 0, 4, 5, 6, 7],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 2, 3, 4, 1, 5],
        orientation: [1, 0, 0, 0, 0, 0]
      }
    },
    l: {
      EDGES: {
        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [0, 1, 6, 2, 4, 3, 5, 7],
        orientation: [0, 0, 2, 1, 0, 2, 1, 0]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 1, 0, 0, 2, 0]
      }
    },
    f: {
      EDGES: {
        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],
        orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]
      },
      CORNERS: {
        permutation: [3, 1, 2, 5, 0, 4, 6, 7],
        orientation: [1, 0, 0, 2, 2, 1, 0, 0]
      },
      CENTERS: {
        permutation: [1, 5, 2, 0, 4, 3],
        orientation: [1, 1, 1, 1, 0, 1]
      }
    },
    r: {
      EDGES: {
        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [4, 0, 2, 3, 7, 5, 6, 1],
        orientation: [2, 1, 0, 0, 1, 0, 0, 2]
      },
      CENTERS: {
        permutation: [2, 1, 5, 3, 0, 4],
        orientation: [0, 0, 0, 1, 2, 2]
      }
    },
    b: {
      EDGES: {
        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],
        orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1]
      },
      CORNERS: {
        permutation: [0, 7, 1, 3, 4, 5, 2, 6],
        orientation: [0, 2, 1, 0, 0, 0, 2, 1]
      },
      CENTERS: {
        permutation: [3, 0, 2, 5, 4, 1],
        orientation: [3, 3, 0, 3, 1, 3]
      }
    },
    d: {
      EDGES: {
        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [0, 1, 2, 3, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [0, 0, 0, 0, 0, 1]
      }
    }
  }
};
cube3x3x3KPuzzleDefinition.experimentalDerivedMoves = {
  Uw: "u",
  Lw: "l",
  Fw: "f",
  Rw: "r",
  Bw: "b",
  Dw: "d",
  Uv: "y",
  Lv: "x'",
  Fv: "z",
  Rv: "x",
  Bv: "z'",
  Dv: "y'",
  "2U": "u U'",
  "2L": "l L'",
  "2F": "f F'",
  "2R": "r R'",
  "2B": "b B'",
  "2D": "d D'"
};
async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(puzzleLoader) {
  const puzzleSpecificSimplifyOptions = await (puzzleLoader.puzzleSpecificSimplifyOptions ?? puzzleLoader.puzzleSpecificSimplifyOptionsPromise);
  if (!puzzleSpecificSimplifyOptions) {
    return {};
  }
  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };
}
var puzzleOrientationCacheRaw = new Array(24);
async function descAsyncGetPuzzleGeometry(desc) {
  const puzzleGeometry = await import("./puzzle-geometry-SH22JMRM.js");
  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle2(desc) {
  const pg = await descAsyncGetPuzzleGeometry(desc);
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = `description: ${desc}`;
  const puzzleGeometry = await import("./puzzle-geometry-SH22JMRM.js");
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var nextCustomID = 1;
function customPGPuzzleLoader(desc, info) {
  const customID = nextCustomID++;
  let cachedKPuzzle = null;
  const kpuzzlePromiseFn = async () => {
    return cachedKPuzzle ?? (cachedKPuzzle = asyncGetKPuzzle2(desc));
  };
  const puzzleLoader = {
    id: `custom-${customID}`,
    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,
    kpuzzle: kpuzzlePromiseFn,
    svg: async () => {
      const pg = await descAsyncGetPuzzleGeometry(desc);
      return pg.generatesvg();
    },
    pg: async () => {
      return descAsyncGetPuzzleGeometry(desc);
    },
    puzzleSpecificSimplifyOptionsPromise: puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn)
  };
  if (info?.inventedBy) {
    puzzleLoader.inventedBy = info.inventedBy;
  }
  if (info?.inventionYear) {
    puzzleLoader.inventionYear = info.inventionYear;
  }
  return puzzleLoader;
}
var experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);
cube3x3x3KPuzzleDefinition.experimentalIsStateSolved = experimentalIs3x3x3Solved;
function puzzleOrientation3x3x3Idx(state) {
  const idxU = state.stateData["CENTERS"].pieces[0];
  const idxD = state.stateData["CENTERS"].pieces[5];
  const unadjustedIdxL = state.stateData["CENTERS"].pieces[1];
  let idxL = unadjustedIdxL;
  if (idxU < unadjustedIdxL) {
    idxL--;
  }
  if (idxD < unadjustedIdxL) {
    idxL--;
  }
  return [idxU, idxL];
}
var puzzleOrientationCacheRaw2 = new Array(6).fill(0).map(() => {
  return new Array(6);
});
var puzzleOrientationCacheInitialized2 = false;
function puzzleOrientation3x3x3Cache() {
  if (!puzzleOrientationCacheInitialized2) {
    {
      const uAlgs = ["", "z", "x", "z'", "x'", "x2"].map((s) => Alg.fromString(s));
      const yAlg = new Alg("y");
      for (const uAlg of uAlgs) {
        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);
        for (let i = 0; i < 4; i++) {
          transformation = transformation.applyAlg(yAlg);
          const [idxU, idxL] = puzzleOrientation3x3x3Idx(transformation.toKState());
          puzzleOrientationCacheRaw2[idxU][idxL] = transformation.invert();
        }
      }
    }
  }
  return puzzleOrientationCacheRaw2;
}
function normalize3x3x3Orientation(state) {
  const [idxU, idxL] = puzzleOrientation3x3x3Idx(state);
  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];
  return state.applyTransformation(orientationTransformation);
}
function experimentalIs3x3x3Solved(state, options) {
  if (options.ignorePuzzleOrientation) {
    state = normalize3x3x3Orientation(state);
  }
  if (options.ignoreCenterOrientation) {
    state = new KState(state.kpuzzle, {
      EDGES: state.stateData.EDGES,
      CORNERS: state.stateData.CORNERS,
      CENTERS: {
        pieces: state.stateData.CENTERS.pieces,
        orientation: new Array(6).fill(0)
      }
    });
  }
  return !!state.experimentalToTransformation()?.isIdentityTransformation();
}

// node_modules/cubing/dist/esm/chunk-STPXM5JX.js
var wcaEvents = {
  "333": { puzzleID: "3x3x3", eventName: "3x3x3 Cube" },
  "222": { puzzleID: "2x2x2", eventName: "2x2x2 Cube" },
  "444": { puzzleID: "4x4x4", eventName: "4x4x4 Cube" },
  "555": { puzzleID: "5x5x5", eventName: "5x5x5 Cube" },
  "666": { puzzleID: "6x6x6", eventName: "6x6x6 Cube" },
  "777": { puzzleID: "7x7x7", eventName: "7x7x7 Cube" },
  "333bf": { puzzleID: "3x3x3", eventName: "3x3x3 Blindfolded" },
  "333fm": { puzzleID: "3x3x3", eventName: "3x3x3 Fewest Moves" },
  "333oh": { puzzleID: "3x3x3", eventName: "3x3x3 One-Handed" },
  clock: { puzzleID: "clock", eventName: "Clock" },
  minx: { puzzleID: "megaminx", eventName: "Megaminx" },
  pyram: { puzzleID: "pyraminx", eventName: "Pyraminx" },
  skewb: { puzzleID: "skewb", eventName: "Skewb" },
  sq1: { puzzleID: "square1", eventName: "Square-1" },
  "444bf": { puzzleID: "4x4x4", eventName: "4x4x4 Blindfolded" },
  "555bf": { puzzleID: "5x5x5", eventName: "5x5x5 Blindfolded" },
  "333mb": { puzzleID: "3x3x3", eventName: "3x3x3 Multi-Blind" }
};
var twizzleEvents = {
  ...wcaEvents,
  fto: { puzzleID: "fto", eventName: "Face-Turning Octahedron" },
  master_tetraminx: {
    puzzleID: "master_tetraminx",
    eventName: "Master Tetraminx"
  },
  kilominx: {
    puzzleID: "kilominx",
    eventName: "Kilominx"
  },
  redi_cube: {
    puzzleID: "redi_cube",
    eventName: "Redi Cube"
  }
};
function eventInfo(event) {
  return twizzleEvents[event] ?? null;
}
var cube2x2x2 = {
  id: "2x2x2",
  fullName: "2\xD72\xD72 Cube",
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).cube2x2x2JSON)),
  svg: async () => {
    return (await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).cube2x2x2SVG;
  },
  pg: getCached(async () => {
    return asyncGetPuzzleGeometry("2x2x2");
  }),
  stickeringMask: (stickering) => cubeLikeStickeringMask(cube2x2x2, stickering),
  stickerings: cubeStickerings
};
function makeSourceInfo(moveStrings, type, from2, to) {
  const output = [];
  for (const moveString of moveStrings) {
    const move = Move.fromString(moveString);
    const { family, amount: direction } = move;
    if (![-1, 1].includes(direction)) {
      throw new Error("Invalid config move");
    }
    output.push({ family, direction, type, from: from2, to });
  }
  return output;
}
var axisInfos = {
  ["x axis"]: {
    sliceDiameter: 3,
    extendsThroughEntirePuzzle: true,
    moveSourceInfos: [
      ...makeSourceInfo(["R"], 0, 0, 3),
      ...makeSourceInfo(["L'"], 1, 0, 3),
      ...makeSourceInfo(["r", "Rw"], 2, 0, 2),
      ...makeSourceInfo(["l'", "Lw'"], 3, 0, 2),
      ...makeSourceInfo(["M'"], 4, 1, 2),
      ...makeSourceInfo(["x", "Uv", "Dv'"], 5, 0, 3)
    ]
  },
  ["y axis"]: {
    sliceDiameter: 3,
    extendsThroughEntirePuzzle: true,
    moveSourceInfos: [
      ...makeSourceInfo(["U"], 0, 0, 3),
      ...makeSourceInfo(["D'"], 1, 0, 3),
      ...makeSourceInfo(["u", "Uw"], 2, 0, 2),
      ...makeSourceInfo(["d'", "Dw'"], 3, 0, 2),
      ...makeSourceInfo(["E'"], 4, 1, 2),
      ...makeSourceInfo(["y", "Uv", "Dv'"], 5, 0, 3)
    ]
  },
  ["z axis"]: {
    sliceDiameter: 3,
    extendsThroughEntirePuzzle: true,
    moveSourceInfos: [
      ...makeSourceInfo(["F"], 0, 0, 3),
      ...makeSourceInfo(["B'"], 1, 0, 3),
      ...makeSourceInfo(["f", "Fw"], 2, 0, 3),
      ...makeSourceInfo(["b'", "Bw'"], 3, 0, 3),
      ...makeSourceInfo(["S"], 4, 1, 2),
      ...makeSourceInfo(["z", "Fv", "Bv'"], 5, 0, 3)
    ]
  }
};
var byFamily = {};
for (const [axis, info] of Object.entries(axisInfos)) {
  for (const moveSourceInfo of info.moveSourceInfos) {
    byFamily[moveSourceInfo.family] = { axis, moveSourceInfo };
  }
}
var byAxisThenType = {};
var _a4;
for (const axis of Object.keys(axisInfos)) {
  const entry = {};
  byAxisThenType[axis] = entry;
  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {
    (entry[_a4 = moveSourceInfo.type] ?? (entry[_a4] = [])).push(moveSourceInfo);
  }
}
var byAxisThenSpecificSlices = {};
for (const axis of Object.keys(axisInfos)) {
  const entry = /* @__PURE__ */ new Map();
  byAxisThenSpecificSlices[axis] = entry;
  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {
    if (!entry.get(moveSourceInfo.from)) {
      entry.set(moveSourceInfo.from, moveSourceInfo);
    }
  }
}
function firstOfType(axis, moveSourceType) {
  const entry = byAxisThenType[axis][moveSourceType]?.[0];
  if (!entry) {
    throw new Error(`Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`);
  }
  return entry;
}
var areQuantumMovesSameAxis = (quantumMove1, quantumMove2) => {
  return byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis;
};
function simplestMove(axis, from2, to, directedAmount) {
  if (from2 + 1 === to) {
    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from2);
    if (sliceSpecificInfo) {
      return new Move(new QuantumMove(sliceSpecificInfo.family), directedAmount * sliceSpecificInfo.direction);
    }
  }
  const axisInfo = axisInfos[axis];
  const { sliceDiameter } = axisInfo;
  if (from2 === 0 && to === sliceDiameter) {
    const moveSourceInfo2 = firstOfType(axis, 5);
    return new Move(new QuantumMove(moveSourceInfo2.family), directedAmount * moveSourceInfo2.direction);
  }
  const far = from2 + to > sliceDiameter;
  if (far) {
    [from2, to] = [sliceDiameter - to, sliceDiameter - from2];
  }
  let outerLayer = from2 + 1;
  let innerLayer = to;
  const slice = outerLayer === innerLayer;
  if (slice) {
    innerLayer = null;
  }
  if (outerLayer === 1) {
    outerLayer = null;
  }
  if (slice && outerLayer === 1) {
    innerLayer = null;
  }
  if (!slice && innerLayer === 2) {
    innerLayer = null;
  }
  const moveSourceType = slice ? far ? 1 : 0 : far ? 3 : 2;
  const moveSourceInfo = firstOfType(axis, moveSourceType);
  return new Move(new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer), directedAmount * moveSourceInfo.direction);
}
function simplifySameAxisMoves(moves, quantumMod = true) {
  if (moves.length === 0) {
    return [];
  }
  const axis = byFamily[moves[0].family].axis;
  const axisInfo = axisInfos[axis];
  const { sliceDiameter } = axisInfo;
  const sliceDeltas = /* @__PURE__ */ new Map();
  let lastCandidateRange = null;
  function adjustValue(idx, relativeDelta) {
    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;
    if (quantumMod) {
      newDelta = newDelta % 4 + 5 % 4 - 1;
    }
    if (newDelta === 0) {
      sliceDeltas.delete(idx);
    } else {
      sliceDeltas.set(idx, newDelta);
    }
  }
  let suffixLength = 0;
  for (const move of Array.from(moves).reverse()) {
    suffixLength++;
    const { moveSourceInfo } = byFamily[move.family];
    const directedAmount2 = move.amount * moveSourceInfo.direction;
    switch (moveSourceInfo.type) {
      case 0: {
        const idx = (move.innerLayer ?? 1) - 1;
        adjustValue(idx, directedAmount2);
        adjustValue(idx + 1, -directedAmount2);
        break;
      }
      case 1: {
        const idx = sliceDiameter - (move.innerLayer ?? 1);
        adjustValue(idx, directedAmount2);
        adjustValue(idx + 1, -directedAmount2);
        break;
      }
      case 2: {
        adjustValue((move.outerLayer ?? 1) - 1, directedAmount2);
        adjustValue(move.innerLayer ?? 2, -directedAmount2);
        break;
      }
      case 3: {
        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount2);
        adjustValue(sliceDiameter - ((move.outerLayer ?? 1) - 1), -directedAmount2);
        break;
      }
      case 4: {
        adjustValue(moveSourceInfo.from, directedAmount2);
        adjustValue(moveSourceInfo.to, -directedAmount2);
        break;
      }
      case 5: {
        adjustValue(0, directedAmount2);
        adjustValue(sliceDiameter, -directedAmount2);
        break;
      }
    }
    if ([0, 2].includes(sliceDeltas.size)) {
      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };
    }
  }
  if (sliceDeltas.size === 0) {
    return [];
  }
  if (!lastCandidateRange) {
    return moves;
  }
  let [from2, to] = lastCandidateRange.sliceDeltas.keys();
  if (from2 > to) {
    [from2, to] = [to, from2];
  }
  const directedAmount = lastCandidateRange.sliceDeltas.get(from2);
  return [
    ...moves.slice(0, -lastCandidateRange.suffixLength),
    ...directedAmount !== 0 ? [simplestMove(axis, from2, to, directedAmount)] : []
  ];
}
var puzzleSpecificSimplifyOptions333 = {
  quantumMoveOrder: () => 4,
  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves }
};
var cube3x3x3 = {
  id: "3x3x3",
  fullName: "3\xD73\xD73 Cube",
  inventedBy: ["Ern\u0151 Rubik"],
  inventionYear: 1974,
  kpuzzle: getCached(async () => {
    return experimental3x3x3KPuzzle;
  }),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-3x3x3-QN5DUJUA-CSMNXCNK.js")).cube3x3x3SVG;
  }),
  llSVG: getCached(async () => {
    return (await import("./puzzles-dynamic-3x3x3-QN5DUJUA-CSMNXCNK.js")).cube3x3x3LLSVG;
  }),
  pg: getCached(async () => {
    return asyncGetPuzzleGeometry("3x3x3");
  }),
  stickeringMask: (stickering) => cubeLikeStickeringMask(cube3x3x3, stickering),
  stickerings: cubeStickerings,
  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333
};
var clock = {
  id: "clock",
  fullName: "Clock",
  inventedBy: ["Christopher C. Wiggs", "Christopher J. Taylor"],
  inventionYear: 1988,
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).clockJSON)),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).clockSVG;
  })
};
async function ftoStickering(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const experimentalFTO_FC = () => m.and([m.move("U"), m.not(m.or(m.moves(["F", "BL", "BR"])))]);
  const experimentalFTO_F2T = () => m.and([m.move("U"), m.not(m.move("F"))]);
  const experimentalFTO_SC = () => m.or([
    experimentalFTO_F2T(),
    m.and([m.move("F"), m.not(m.or(m.moves(["U", "BL", "BR"])))])
  ]);
  const experimentalFTO_L2C = () => m.not(m.or([
    m.and([m.move("U"), m.move("F")]),
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  const experimentalFTO_LBT = () => m.not(m.or([
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  switch (stickering) {
    case "full":
      break;
    case "experimental-fto-fc": {
      puzzleStickering.set(m.not(experimentalFTO_FC()), "Ignored");
      break;
    }
    case "experimental-fto-f2t": {
      puzzleStickering.set(m.not(experimentalFTO_F2T()), "Ignored");
      puzzleStickering.set(experimentalFTO_FC(), "Dim");
      break;
    }
    case "experimental-fto-sc": {
      puzzleStickering.set(m.not(experimentalFTO_SC()), "Ignored");
      puzzleStickering.set(experimentalFTO_F2T(), "Dim");
      break;
    }
    case "experimental-fto-l2c": {
      puzzleStickering.set(m.not(experimentalFTO_L2C()), "Ignored");
      puzzleStickering.set(experimentalFTO_SC(), "Dim");
      break;
    }
    case "experimental-fto-lbt": {
      puzzleStickering.set(m.not(experimentalFTO_LBT()), "Ignored");
      puzzleStickering.set(experimentalFTO_L2C(), "Dim");
      break;
    }
    case "experimental-fto-l3t": {
      puzzleStickering.set(experimentalFTO_LBT(), "Dim");
      break;
    }
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim");
  }
  return puzzleStickering.toStickeringMask();
}
async function ftoStickerings() {
  return [
    "full",
    "experimental-fto-fc",
    "experimental-fto-f2t",
    "experimental-fto-sc",
    "experimental-fto-l2c",
    "experimental-fto-lbt",
    "experimental-fto-l3t"
  ];
}
var FTOPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      pgID: "FTO",
      id: "fto",
      fullName: "Face-Turning Octahedron",
      inventedBy: ["Karl Rohrbach", "David Pitcher"],
      inventionYear: 1983
    });
    this.stickerings = ftoStickerings;
    this.svg = getCached(async () => {
      return (await import("./puzzles-dynamic-unofficial-QXSDLTK5-ZJKILHOO.js")).ftoSVG;
    });
  }
  stickeringMask(stickering) {
    return ftoStickering(this, stickering);
  }
};
var fto = new FTOPuzzleLoader();
async function megaminxStickeringMask(puzzleLoader, stickering) {
  switch (stickering) {
    case "full":
    case "F2L":
    case "LL":
    case "OLL":
    case "EOLL":
    case "OCLL":
    case "PLL":
    case "ELS":
    case "CLS":
      return cubeLikeStickeringMask(puzzleLoader, stickering);
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
  }
  return cubeLikeStickeringMask(puzzleLoader, "full");
}
async function megaminxStickerings() {
  return ["full", "F2L", "LL", "OLL", "EOLL", "OCLL", "PLL", "ELS", "CLS"];
}
var MegaminxPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      id: "megaminx",
      fullName: "Megaminx",
      inventionYear: 1981
    });
    this.stickerings = megaminxStickerings;
  }
  stickeringMask(stickering) {
    return megaminxStickeringMask(this, stickering);
  }
};
var megaminx = new MegaminxPuzzleLoader();
var PyraminxPuzzleLoader = class extends PGPuzzleLoader {
  constructor() {
    super({
      id: "pyraminx",
      fullName: "Pyraminx",
      inventedBy: ["Uwe Meffert"]
    });
    this.svg = getCached(async () => {
      return (await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).pyraminxSVG;
    });
  }
};
var pyraminx = new PyraminxPuzzleLoader();
var square1 = {
  id: "square1",
  fullName: "Square-1",
  inventedBy: ["Karel Hr\u0161el", "Vojtech Kopsk\xFD"],
  inventionYear: 1990,
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).sq1HyperOrbitJSON)),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).sq1HyperOrbitSVG;
  })
};
var kilominx = {
  id: "kilominx",
  fullName: "Kilominx",
  kpuzzle: getCached(async () => {
    const pg = await asyncGetPuzzleGeometry("megaminx + chopasaurus");
    const kpuzzleDefinition = JSON.parse(JSON.stringify(pg.getKPuzzleDefinition(true)));
    delete kpuzzleDefinition.orbits.CENTERS;
    delete kpuzzleDefinition.orbits.CENTERS2;
    delete kpuzzleDefinition.startStateData.CENTERS;
    delete kpuzzleDefinition.startStateData.CENTERS2;
    for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {
      delete moveDefinition.CENTERS;
      delete moveDefinition.CENTERS2;
    }
    kpuzzleDefinition.name = "kilominx";
    delete kpuzzleDefinition.experimentalPuzzleDescription;
    const puzzleGeometry = await import("./puzzle-geometry-SH22JMRM.js");
    const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
    const kpuzzle = new KPuzzle(kpuzzleDefinition, {
      experimentalPGNotation: {
        lookupMove: (move) => {
          if (move.toString() === "x2" || move.toString() === "x2'") {
            return x2Transformation.transformationData;
          }
          return pgNotation.lookupMove(move);
        }
      }
    });
    const x2Transformation = kpuzzle.algToTransformation("Rv2 Fv Uv'");
    kpuzzleDefinition.moves["x2"] = x2Transformation;
    return kpuzzle;
  }),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-unofficial-QXSDLTK5-ZJKILHOO.js")).kilominxSVG;
  })
};
var rediCube = {
  id: "redi_cube",
  fullName: "Redi Cube",
  inventedBy: ["Oskar van Deventer"],
  inventionYear: 2009,
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-unofficial-QXSDLTK5-ZJKILHOO.js")).rediCubeJSON)),
  svg: async () => {
    return (await import("./puzzles-dynamic-unofficial-QXSDLTK5-ZJKILHOO.js")).rediCubeSVG;
  }
};
var cube4x4x4 = new CubePGPuzzleLoader({
  id: "4x4x4",
  fullName: "4\xD74\xD74 Cube"
});
cube4x4x4.llSVG = getCached(async () => {
  return (await import("./puzzles-dynamic-4x4x4-DT42HVIY-6O6X5GGY.js")).cube4x4x4LLSVG;
});
var melindas2x2x2x2 = {
  id: "melindas2x2x2x2",
  fullName: "Melinda's 2\xD72\xD72\xD72",
  inventedBy: ["Melinda Green"],
  kpuzzle: getCached(async () => new KPuzzle((await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).melindas2x2x2x2OrbitJSON)),
  svg: getCached(async () => {
    return (await import("./puzzles-dynamic-side-events-T2YVO2CD-E6CCCQF5.js")).melindas2x2x2x2OrbitSVG;
  })
};
var puzzles = {
  "3x3x3": cube3x3x3,
  "2x2x2": cube2x2x2,
  "4x4x4": cube4x4x4,
  "5x5x5": new CubePGPuzzleLoader({ id: "5x5x5", fullName: "5\xD75\xD75 Cube" }),
  "6x6x6": new CubePGPuzzleLoader({ id: "6x6x6", fullName: "6\xD76\xD76 Cube" }),
  "7x7x7": new CubePGPuzzleLoader({ id: "7x7x7", fullName: "7\xD77\xD77 Cube" }),
  "40x40x40": new CubePGPuzzleLoader({
    id: "40x40x40",
    fullName: "40\xD740\xD740 Cube"
  }),
  clock,
  megaminx,
  pyraminx,
  skewb: new PGPuzzleLoader({
    id: "skewb",
    fullName: "Skewb",
    inventedBy: ["Tony Durham"]
  }),
  square1,
  fto,
  gigaminx: new PGPuzzleLoader({
    id: "gigaminx",
    fullName: "Gigaminx",
    inventedBy: ["Tyler Fox"],
    inventionYear: 2006
  }),
  master_tetraminx: new PGPuzzleLoader({
    pgID: "master tetraminx",
    id: "master_tetraminx",
    fullName: "Master Tetraminx",
    inventedBy: ["Katsuhiko Okamoto"],
    inventionYear: 2002
  }),
  kilominx,
  redi_cube: rediCube,
  melindas2x2x2x2
};

// node_modules/cubing/dist/esm/chunk-4RNFY2SZ.js
var twistyDebugGlobals = {
  shareAllNewRenderers: "auto",
  showRenderStats: false
};
var _latestAssignedIdx, _latestResolvedIdx, _a5;
var StaleDropper = (_a5 = class {
  constructor() {
    __privateAdd(this, _latestAssignedIdx, 0);
    __privateAdd(this, _latestResolvedIdx, 0);
  }
  queue(p) {
    return new Promise(async (resolve, reject) => {
      try {
        const idx = ++__privateWrapper(this, _latestAssignedIdx)._;
        const result = await p;
        if (idx > __privateGet(this, _latestResolvedIdx)) {
          __privateSet(this, _latestResolvedIdx, idx);
          resolve(result);
        }
      } catch (e) {
        reject(e);
      }
    });
  }
}, _latestAssignedIdx = new WeakMap(), _latestResolvedIdx = new WeakMap(), _a5);
var globalSourceGeneration = 0;
var _children, _rawListeners, _scheduleRawDispatch, scheduleRawDispatch_fn, _rawDispatchPending, _dispatchRawListeners, dispatchRawListeners_fn, _freshListeners, _a6;
var TwistyPropParent = (_a6 = class {
  constructor() {
    __privateAdd(this, _scheduleRawDispatch);
    __privateAdd(this, _dispatchRawListeners);
    __privateAdd(this, _children, void 0);
    __privateAdd(this, _rawListeners, void 0);
    __privateAdd(this, _rawDispatchPending, void 0);
    __privateAdd(this, _freshListeners, void 0);
    __privateSet(this, _children, /* @__PURE__ */ new Set());
    this.lastSourceGeneration = 0;
    __privateSet(this, _rawListeners, /* @__PURE__ */ new Set());
    __privateSet(this, _rawDispatchPending, false);
    __privateSet(this, _freshListeners, /* @__PURE__ */ new Map());
  }
  canReuse(v1, v2) {
    return v1 === v2 || this.canReuseValue(v1, v2);
  }
  canReuseValue(_v1, _v2) {
    return false;
  }
  debugGetChildren() {
    return Array.from(__privateGet(this, _children).values());
  }
  addChild(child) {
    __privateGet(this, _children).add(child);
  }
  removeChild(child) {
    __privateGet(this, _children).delete(child);
  }
  markStale(sourceEvent) {
    if (sourceEvent.detail.generation !== globalSourceGeneration) {
      throw new Error("A TwistyProp was marked stale too late!");
    }
    if (this.lastSourceGeneration === sourceEvent.detail.generation) {
      return;
    }
    this.lastSourceGeneration = sourceEvent.detail.generation;
    for (const child of __privateGet(this, _children)) {
      child.markStale(sourceEvent);
    }
    __privateMethod(this, _scheduleRawDispatch, scheduleRawDispatch_fn).call(this);
  }
  addRawListener(listener, options) {
    __privateGet(this, _rawListeners).add(listener);
    if (options?.initial) {
      listener();
    }
  }
  removeRawListener(listener) {
    __privateGet(this, _rawListeners).delete(listener);
  }
  addFreshListener(listener) {
    const staleDropper = new StaleDropper();
    let lastResult = null;
    const callback = async () => {
      const result = await staleDropper.queue(this.get());
      if (lastResult !== null && this.canReuse(lastResult, result)) {
        return;
      }
      lastResult = result;
      listener(result);
    };
    __privateGet(this, _freshListeners).set(listener, callback);
    this.addRawListener(callback, { initial: true });
  }
  removeFreshListener(listener) {
    this.removeRawListener(__privateGet(this, _freshListeners).get(listener));
    __privateGet(this, _freshListeners).delete(listener);
  }
}, _children = new WeakMap(), _rawListeners = new WeakMap(), _scheduleRawDispatch = new WeakSet(), scheduleRawDispatch_fn = function() {
  if (!__privateGet(this, _rawDispatchPending)) {
    __privateSet(this, _rawDispatchPending, true);
    setTimeout(() => __privateMethod(this, _dispatchRawListeners, dispatchRawListeners_fn).call(this), 0);
  }
}, _rawDispatchPending = new WeakMap(), _dispatchRawListeners = new WeakSet(), dispatchRawListeners_fn = function() {
  if (!__privateGet(this, _rawDispatchPending)) {
    throw new Error("Invalid dispatch state!");
  }
  for (const listener of __privateGet(this, _rawListeners)) {
    listener();
  }
  __privateSet(this, _rawDispatchPending, false);
}, _freshListeners = new WeakMap(), _a6);
var _value, _a7;
var TwistyPropSource = (_a7 = class extends TwistyPropParent {
  constructor(initialValue) {
    super();
    __privateAdd(this, _value, void 0);
    __privateSet(this, _value, from(() => this.getDefaultValue()));
    if (initialValue) {
      __privateSet(this, _value, this.deriveFromPromiseOrValue(initialValue, __privateGet(this, _value)));
    }
  }
  set(input) {
    __privateSet(this, _value, this.deriveFromPromiseOrValue(input, __privateGet(this, _value)));
    const sourceEventDetail = {
      sourceProp: this,
      value: __privateGet(this, _value),
      generation: ++globalSourceGeneration
    };
    this.markStale(new CustomEvent("stale", {
      detail: sourceEventDetail
    }));
  }
  async get() {
    return __privateGet(this, _value);
  }
  async deriveFromPromiseOrValue(input, oldValuePromise) {
    return this.derive(await input, oldValuePromise);
  }
}, _value = new WeakMap(), _a7);
var SimpleTwistyPropSource = class extends TwistyPropSource {
  derive(input) {
    return input;
  }
};
var NO_VALUE = Symbol("no value");
var _parents, _cachedLastSuccessfulCalculation, _cachedLatestGenerationCalculation, _getParents, getParents_fn, _cacheDerive, cacheDerive_fn, _a8;
var TwistyPropDerived = (_a8 = class extends TwistyPropParent {
  constructor(parents, userVisibleErrorTracker) {
    super();
    __privateAdd(this, _getParents);
    __privateAdd(this, _cacheDerive);
    __privateAdd(this, _parents, void 0);
    __privateAdd(this, _cachedLastSuccessfulCalculation, null);
    __privateAdd(this, _cachedLatestGenerationCalculation, null);
    this.userVisibleErrorTracker = userVisibleErrorTracker;
    __privateSet(this, _parents, parents);
    for (const parent of Object.values(parents)) {
      parent.addChild(this);
    }
  }
  async get() {
    const generation = this.lastSourceGeneration;
    if (__privateGet(this, _cachedLatestGenerationCalculation)?.generation === generation) {
      return __privateGet(this, _cachedLatestGenerationCalculation).output;
    }
    const latestGenerationCalculation = {
      generation,
      output: __privateMethod(this, _cacheDerive, cacheDerive_fn).call(this, __privateMethod(this, _getParents, getParents_fn).call(this), generation, __privateGet(this, _cachedLastSuccessfulCalculation))
    };
    __privateSet(this, _cachedLatestGenerationCalculation, latestGenerationCalculation);
    this.userVisibleErrorTracker?.reset();
    return latestGenerationCalculation.output;
  }
}, _parents = new WeakMap(), _cachedLastSuccessfulCalculation = new WeakMap(), _cachedLatestGenerationCalculation = new WeakMap(), _getParents = new WeakSet(), getParents_fn = async function() {
  const inputValuePromises = {};
  for (const [key, parent] of Object.entries(__privateGet(this, _parents))) {
    inputValuePromises[key] = parent.get();
  }
  const inputs = {};
  for (const key in __privateGet(this, _parents)) {
    inputs[key] = await inputValuePromises[key];
  }
  return inputs;
}, _cacheDerive = new WeakSet(), cacheDerive_fn = async function(inputsPromise, generation, cachedLatestGenerationCalculation = null) {
  const inputs = await inputsPromise;
  const cache = (output) => {
    __privateSet(this, _cachedLastSuccessfulCalculation, {
      inputs,
      output: Promise.resolve(output),
      generation
    });
    return output;
  };
  if (!cachedLatestGenerationCalculation) {
    return cache(await this.derive(inputs));
  }
  const cachedInputs = cachedLatestGenerationCalculation.inputs;
  for (const key in __privateGet(this, _parents)) {
    const parent = __privateGet(this, _parents)[key];
    if (!parent.canReuse(inputs[key], cachedInputs[key])) {
      return cache(await this.derive(inputs));
    }
  }
  return cachedLatestGenerationCalculation.output;
}, _a8);
var _disconnectionFunctions, _a9;
var FreshListenerManager = (_a9 = class {
  constructor() {
    __privateAdd(this, _disconnectionFunctions, []);
  }
  addListener(prop, listener) {
    let disconnected = false;
    const wrappedListener = (value) => {
      if (disconnected) {
        return;
      }
      listener(value);
    };
    prop.addFreshListener(wrappedListener);
    __privateGet(this, _disconnectionFunctions).push(() => {
      prop.removeFreshListener(wrappedListener);
      disconnected = true;
    });
  }
  addMultiListener3(props, listener) {
    this.addMultiListener(props, listener);
  }
  addMultiListener(props, listener) {
    let disconnected = false;
    let initialIgnoresLeft = props.length - 1;
    const wrappedListener = async (_) => {
      if (initialIgnoresLeft > 0) {
        initialIgnoresLeft--;
        return;
      }
      if (disconnected) {
        return;
      }
      const promises = props.map((prop) => prop.get());
      const values = await Promise.all(promises);
      listener(values);
    };
    for (const prop of props) {
      prop.addFreshListener(wrappedListener);
    }
    __privateGet(this, _disconnectionFunctions).push(() => {
      for (const prop of props) {
        prop.removeFreshListener(wrappedListener);
      }
      disconnected = true;
    });
  }
  disconnect() {
    for (const disconnectionFunction of __privateGet(this, _disconnectionFunctions)) {
      disconnectionFunction();
    }
  }
}, _disconnectionFunctions = new WeakMap(), _a9);
var RenderScheduler = class {
  constructor(callback) {
    this.callback = callback;
    this.animFrameID = null;
    this.animFrame = this.animFrameWrapper.bind(this);
  }
  requestIsPending() {
    return !!this.animFrameID;
  }
  requestAnimFrame() {
    if (!this.animFrameID) {
      this.animFrameID = requestAnimationFrame(this.animFrame);
    }
  }
  cancelAnimFrame() {
    if (this.animFrameID) {
      cancelAnimationFrame(this.animFrameID);
      this.animFrameID = 0;
    }
  }
  animFrameWrapper(timestamp) {
    this.animFrameID = 0;
    this.callback(timestamp);
  }
};
var hintFaceletStyles = {
  floating: true,
  none: true
};
var HintFaceletProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};
var TAU = Math.PI * 2;
var DEGREES_PER_RADIAN = 360 / TAU;
var HTMLElementStub = class {
};
var HTMLElementShim;
if (globalThis.HTMLElement) {
  HTMLElementShim = HTMLElement;
} else {
  HTMLElementShim = HTMLElementStub;
}
var CustomElementsStub = class {
  define() {
  }
};
var customElementsShim;
if (globalThis.customElements) {
  customElementsShim = customElements;
} else {
  customElementsShim = new CustomElementsStub();
}
var CSSSource = class {
  constructor(sourceText) {
    this.sourceText = sourceText;
  }
  getAsString() {
    return this.sourceText;
  }
};
var _cssSourceMap, _a10;
var ManagedCustomElement = (_a10 = class extends HTMLElementShim {
  constructor(options) {
    super();
    __privateAdd(this, _cssSourceMap, void 0);
    __privateSet(this, _cssSourceMap, /* @__PURE__ */ new Map());
    this.shadow = this.attachShadow({ mode: options?.mode ?? "closed" });
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.classList.add("wrapper");
    this.shadow.appendChild(this.contentWrapper);
  }
  addCSS(cssSource) {
    const existing = __privateGet(this, _cssSourceMap).get(cssSource);
    if (existing) {
      return existing;
    }
    const cssElem = document.createElement("style");
    cssElem.textContent = cssSource.getAsString();
    __privateGet(this, _cssSourceMap).set(cssSource, cssElem);
    this.shadow.appendChild(cssElem);
    return cssElem;
  }
  removeCSS(cssSource) {
    const cssElem = __privateGet(this, _cssSourceMap).get(cssSource);
    if (!cssElem) {
      return;
    }
    this.shadow.removeChild(cssElem);
    __privateGet(this, _cssSourceMap).delete(cssSource);
  }
  addElement(element) {
    return this.contentWrapper.appendChild(element);
  }
  prependElement(element) {
    this.contentWrapper.prepend(element);
  }
  removeElement(element) {
    return this.contentWrapper.removeChild(element);
  }
}, _cssSourceMap = new WeakMap(), _a10);
customElementsShim.define("twisty-managed-custom-element", ManagedCustomElement);
var performance = globalThis.performance;
var Stats = class {
  constructor() {
    this.mode = 0;
    this.dom = document.createElement("div");
    this.beginTime = (performance || Date).now();
    this.prevTime = this.beginTime;
    this.frames = 0;
    this.fpsPanel = this.addPanel(new StatsPanel("FPS", "#0ff", "#002"));
    this.msPanel = this.addPanel(new StatsPanel("MS", "#0f0", "#020"));
    this.memPanel = performance?.memory ? this.addPanel(new StatsPanel("MB", "#f08", "#201")) : null;
    this.REVISION = 16;
    this.dom.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
    this.dom.addEventListener("click", (event) => {
      event.preventDefault();
      this.showPanel(++this.mode % this.dom.children.length);
    }, false);
    this.showPanel(0);
  }
  addPanel(panel) {
    this.dom.appendChild(panel.dom);
    return panel;
  }
  showPanel(id) {
    for (let i = 0; i < this.dom.children.length; i++) {
      this.dom.children[i].style.display = i === id ? "block" : "none";
    }
    this.mode = id;
  }
  begin() {
    this.beginTime = (performance || Date).now();
  }
  end() {
    this.frames++;
    const time = (performance || Date).now();
    this.msPanel.update(time - this.beginTime, 200);
    if (time >= this.prevTime + 1e3) {
      this.fpsPanel.update(this.frames * 1e3 / (time - this.prevTime), 100);
      this.prevTime = time;
      this.frames = 0;
      if (this.memPanel) {
        const memory = performance.memory;
        this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
      }
    }
    return time;
  }
  update() {
    this.beginTime = this.end();
  }
};
var PR = Math.round(globalThis?.window?.devicePixelRatio ?? 1);
var WIDTH = 80 * PR;
var HEIGHT = 48 * PR;
var TEXT_X = 3 * PR;
var TEXT_Y = 2 * PR;
var GRAPH_X = 3 * PR;
var GRAPH_Y = 15 * PR;
var GRAPH_WIDTH = 74 * PR;
var GRAPH_HEIGHT = 30 * PR;
var StatsPanel = class {
  constructor(name, fg, bg) {
    this.name = name;
    this.fg = fg;
    this.bg = bg;
    this.min = Infinity;
    this.max = 0;
    this.dom = document.createElement("canvas");
    this.context = this.dom.getContext("2d");
    this.dom.width = WIDTH;
    this.dom.height = HEIGHT;
    this.dom.style.cssText = "width:80px;height:48px";
    this.context.font = `bold ${9 * PR}px Helvetica,Arial,sans-serif`;
    this.context.textBaseline = "top";
    this.context.fillStyle = bg;
    this.context.fillRect(0, 0, WIDTH, HEIGHT);
    this.context.fillStyle = fg;
    this.context.fillText(name, TEXT_X, TEXT_Y);
    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
    this.context.fillStyle = bg;
    this.context.globalAlpha = 0.9;
    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  }
  update(value, maxValue) {
    this.min = Math.min(this.min, value);
    this.max = Math.max(this.max, value);
    this.context.fillStyle = this.bg;
    this.context.globalAlpha = 1;
    this.context.fillRect(0, 0, WIDTH, GRAPH_Y);
    this.context.fillStyle = this.fg;
    this.context.fillText(`${Math.round(value)} ${this.name} (${Math.round(this.min)}-${Math.round(this.max)})`, TEXT_X, TEXT_Y);
    this.context.drawImage(this.dom, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
    this.context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
    this.context.fillStyle = this.bg;
    this.context.globalAlpha = 0.9;
    this.context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, Math.round((1 - value / maxValue) * GRAPH_HEIGHT));
  }
};
var cachedConstructorProxy = null;
async function proxy3D() {
  return cachedConstructorProxy ?? (cachedConstructorProxy = import("./twisty-dynamic-3d-BJ3NLJBJ-M6UGQFLO.js"));
}
var THREEJS = from(async () => (await proxy3D()).T3I);
var globalPixelRatioOverride = null;
function pixelRatio() {
  return globalPixelRatioOverride ?? (devicePixelRatio || 1);
}
var twisty3DVantageCSS = new CSSSource(`
:host {
  width: 384px;
  height: 256px;
  display: grid;
}

.wrapper {
  width: 100%;
  height: 100%;
  display: grid;
  overflow: hidden;
  place-content: center;
  contain: strict;
}

.loading {
  width: 4em;
  height: 4em;
  border-radius: 2.5em;
  border: 0.5em solid rgba(0, 0, 0, 0);
  border-top: 0.5em solid rgba(0, 0, 0, 0.7);
  border-right: 0.5em solid rgba(0, 0, 0, 0.7);
  animation: fade-in-delayed 4s, rotate 1s linear infinite;
}

@keyframes fade-in-delayed {
  0% { opacity: 0; }
  25% {opacity: 0; }
  100% { opacity: 1; }
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* TODO: This is due to stats hack. Replace with \`canvas\`. */
.wrapper > canvas {
  max-width: 100%;
  max-height: 100%;
  animation: fade-in 0.25s ease-in;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.wrapper.invisible {
  opacity: 0;
}

.wrapper.drag-input-enabled > canvas {
  cursor: grab;
}

.wrapper.drag-input-enabled > canvas:active {
  cursor: grabbing;
}
`);
var MOVEMENT_EPSILON = 0.1;
var _dragInfoMap, _targetListeners, _lazyListenersRegistered, _registerLazyListeners, registerLazyListeners_fn, _clear, clear_fn, _trackDrag, trackDrag_fn, _a11;
var DragTracker = (_a11 = class extends EventTarget {
  constructor(target) {
    super();
    __privateAdd(this, _registerLazyListeners);
    __privateAdd(this, _clear);
    __privateAdd(this, _trackDrag);
    __privateAdd(this, _dragInfoMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _targetListeners, /* @__PURE__ */ new Map());
    __privateAdd(this, _lazyListenersRegistered, false);
    this.target = target;
  }
  start() {
    this.addTargetListener("pointerdown", this.onPointerDown.bind(this));
    this.addTargetListener("contextmenu", (e) => {
      e.preventDefault();
    });
    this.addTargetListener("touchmove", (e) => e.preventDefault());
    this.addTargetListener("dblclick", (e) => e.preventDefault());
  }
  stop() {
    for (const [eventType, listener] of __privateGet(this, _targetListeners).entries()) {
      this.target.removeEventListener(eventType, listener);
    }
    __privateGet(this, _targetListeners).clear();
    __privateSet(this, _lazyListenersRegistered, false);
  }
  addTargetListener(eventType, listener) {
    if (!__privateGet(this, _targetListeners).has(eventType)) {
      this.target.addEventListener(eventType, listener);
      __privateGet(this, _targetListeners).set(eventType, listener);
    }
  }
  onPointerDown(e) {
    __privateMethod(this, _registerLazyListeners, registerLazyListeners_fn).call(this);
    const newDragInfo = {
      attachedInfo: {},
      hasMoved: false,
      lastClientX: e.clientX,
      lastClientY: e.clientY,
      lastTimeStamp: e.timeStamp
    };
    __privateGet(this, _dragInfoMap).set(e.pointerId, newDragInfo);
    this.target.setPointerCapture(e.pointerId);
  }
  onPointerMove(e) {
    const movementInfo = __privateMethod(this, _trackDrag, trackDrag_fn).call(this, e).movementInfo;
    if (movementInfo) {
      e.preventDefault();
      this.dispatchEvent(new CustomEvent("move", {
        detail: movementInfo
      }));
    }
  }
  onPointerUp(e) {
    const trackDragResult = __privateMethod(this, _trackDrag, trackDrag_fn).call(this, e);
    const existing = __privateGet(this, _dragInfoMap).get(e.pointerId);
    __privateMethod(this, _clear, clear_fn).call(this, e);
    this.target.releasePointerCapture(e.pointerId);
    let event;
    if (trackDragResult.hasMoved) {
      event = new CustomEvent("up", {
        detail: { attachedInfo: existing.attachedInfo }
      });
    } else {
      const { altKey, ctrlKey, metaKey, shiftKey } = e;
      event = new CustomEvent("press", {
        detail: {
          normalizedX: e.offsetX / this.target.offsetWidth * 2 - 1,
          normalizedY: 1 - e.offsetY / this.target.offsetHeight * 2,
          rightClick: !!(e.button & 2),
          keys: {
            altKey,
            ctrlOrMetaKey: ctrlKey || metaKey,
            shiftKey
          }
        }
      });
    }
    this.dispatchEvent(event);
  }
}, _dragInfoMap = new WeakMap(), _targetListeners = new WeakMap(), _lazyListenersRegistered = new WeakMap(), _registerLazyListeners = new WeakSet(), registerLazyListeners_fn = function() {
  if (__privateGet(this, _lazyListenersRegistered)) {
    return;
  }
  this.addTargetListener("pointermove", this.onPointerMove.bind(this));
  this.addTargetListener("pointerup", this.onPointerUp.bind(this));
  __privateSet(this, _lazyListenersRegistered, true);
}, _clear = new WeakSet(), clear_fn = function(e) {
  __privateGet(this, _dragInfoMap).delete(e.pointerId);
}, _trackDrag = new WeakSet(), trackDrag_fn = function(e) {
  const existing = __privateGet(this, _dragInfoMap).get(e.pointerId);
  if (!existing) {
    return { movementInfo: null, hasMoved: false };
  }
  let movementInfo;
  if ((e.movementX ?? 0) !== 0 || (e.movementY ?? 0) !== 0) {
    movementInfo = {
      attachedInfo: existing.attachedInfo,
      movementX: e.movementX,
      movementY: e.movementY,
      elapsedMs: e.timeStamp - existing.lastTimeStamp
    };
  } else {
    movementInfo = {
      attachedInfo: existing.attachedInfo,
      movementX: e.clientX - existing.lastClientX,
      movementY: e.clientY - existing.lastClientY,
      elapsedMs: e.timeStamp - existing.lastTimeStamp
    };
  }
  existing.lastClientX = e.clientX;
  existing.lastClientY = e.clientY;
  existing.lastTimeStamp = e.timeStamp;
  if (Math.abs(movementInfo.movementX) < MOVEMENT_EPSILON && Math.abs(movementInfo.movementY) < MOVEMENT_EPSILON) {
    return { movementInfo: null, hasMoved: existing.hasMoved };
  } else {
    existing.hasMoved = true;
    return { movementInfo, hasMoved: existing.hasMoved };
  }
}, _a11);
var renderers = [];
async function rawRenderPooled(width, height, scene, camera) {
  if (renderers.length === 0) {
    renderers.push(newRenderer());
  }
  const renderer = await renderers[0];
  renderer.setSize(width, height);
  renderer.render(scene, camera);
  return renderer.domElement;
}
async function renderPooled(width, height, canvas, scene, camera) {
  if (width === 0 || height === 0) {
    return;
  }
  if (renderers.length === 0) {
    renderers.push(newRenderer());
  }
  const rendererCanvas = await rawRenderPooled(width, height, scene, camera);
  const context = canvas.getContext("2d");
  context.clearRect(0, 0, canvas.width, canvas.height);
  context.drawImage(rendererCanvas, 0, 0);
}
async function newRenderer() {
  const rendererConstructor = (await THREEJS).WebGLRenderer;
  const renderer = new rendererConstructor({
    antialias: true,
    alpha: true
  });
  renderer.setPixelRatio(pixelRatio());
  return renderer;
}
var INERTIA_DEFAULT = true;
var INERTIA_DURATION_MS = 500;
var INERTIA_TIMEOUT_MS = 50;
var VERTICAL_MOVEMENT_BASE_SCALE = 0.75;
function momentumScale(progress) {
  return (Math.exp(1 - progress) - (1 - progress)) / (1 - Math.E) + 1;
}
var Inertia = class {
  constructor(startTimestamp, momentumX, momentumY, callback) {
    this.startTimestamp = startTimestamp;
    this.momentumX = momentumX;
    this.momentumY = momentumY;
    this.callback = callback;
    this.scheduler = new RenderScheduler(this.render.bind(this));
    this.scheduler.requestAnimFrame();
    this.lastTimestamp = startTimestamp;
  }
  render(now) {
    const progressBefore = (this.lastTimestamp - this.startTimestamp) / INERTIA_DURATION_MS;
    const progressAfter = Math.min(1, (now - this.startTimestamp) / INERTIA_DURATION_MS);
    if (progressBefore === 0 && progressAfter > INERTIA_TIMEOUT_MS / INERTIA_DURATION_MS) {
      return;
    }
    const delta = momentumScale(progressAfter) - momentumScale(progressBefore);
    this.callback(this.momentumX * delta * 1e3, this.momentumY * delta * 1e3);
    if (progressAfter < 1) {
      this.scheduler.requestAnimFrame();
    }
    this.lastTimestamp = now;
  }
};
var TwistyOrbitControls = class {
  constructor(model, mirror, canvas, dragTracker) {
    this.model = model;
    this.mirror = mirror;
    this.canvas = canvas;
    this.dragTracker = dragTracker;
    this.experimentalInertia = INERTIA_DEFAULT;
    this.onMovementBound = this.onMovement.bind(this);
    this.experimentalHasBeenMoved = false;
    this.dragTracker.addEventListener("move", this.onMove.bind(this));
    this.dragTracker.addEventListener("up", this.onUp.bind(this));
  }
  temperMovement(f) {
    return Math.sign(f) * Math.log(Math.abs(f * 10) + 1) / 6;
  }
  onMove(e) {
    var _a13;
    (_a13 = e.detail).attachedInfo ?? (_a13.attachedInfo = {});
    const { temperedX, temperedY } = this.onMovement(e.detail.movementX, e.detail.movementY);
    const attachedInfo = e.detail.attachedInfo;
    attachedInfo.lastTemperedX = temperedX * 10;
    attachedInfo.lastTemperedY = temperedY * 10;
    attachedInfo.timestamp = e.timeStamp;
  }
  onMovement(movementX, movementY) {
    const scale = this.mirror ? -1 : 1;
    const minDim = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight);
    const temperedX = this.temperMovement(movementX / minDim);
    const temperedY = this.temperMovement(movementY / minDim * VERTICAL_MOVEMENT_BASE_SCALE);
    this.model.twistySceneModel.orbitCoordinatesRequest.set((async () => {
      const prevCoords = await this.model.twistySceneModel.orbitCoordinates.get();
      const newCoords = {
        latitude: prevCoords.latitude + 2 * temperedY * DEGREES_PER_RADIAN * scale,
        longitude: prevCoords.longitude - 2 * temperedX * DEGREES_PER_RADIAN
      };
      return newCoords;
    })());
    return { temperedX, temperedY };
  }
  onUp(e) {
    e.preventDefault();
    if ("lastTemperedX" in e.detail.attachedInfo && "lastTemperedY" in e.detail.attachedInfo && "timestamp" in e.detail.attachedInfo && e.timeStamp - e.detail.attachedInfo.timestamp < 60) {
      new Inertia(e.timeStamp, e.detail.attachedInfo.lastTemperedX, e.detail.attachedInfo.lastTemperedY, this.onMovementBound);
    }
  }
};
async function setCameraFromOrbitCoordinates(camera, orbitCoordinates, backView = false) {
  const spherical = new (await THREEJS).Spherical(orbitCoordinates.distance, (90 - (backView ? -1 : 1) * orbitCoordinates.latitude) / DEGREES_PER_RADIAN, ((backView ? 180 : 0) + orbitCoordinates.longitude) / DEGREES_PER_RADIAN);
  spherical.makeSafe();
  camera.position.setFromSpherical(spherical);
  camera.lookAt(0, 0, 0);
}
var dedicatedRenderersSoFar = 0;
var DEFAULT_MAX_DEDICATED_RENDERERS = 2;
var sharingRenderers = false;
function shareRenderer() {
  if (twistyDebugGlobals.shareAllNewRenderers !== "auto") {
    if (!twistyDebugGlobals.shareAllNewRenderers) {
      dedicatedRenderersSoFar++;
    }
    return twistyDebugGlobals.shareAllNewRenderers !== "never";
  }
  if (dedicatedRenderersSoFar < DEFAULT_MAX_DEDICATED_RENDERERS) {
    dedicatedRenderersSoFar++;
    return false;
  } else {
    sharingRenderers = true;
    return true;
  }
}
function haveStartedSharingRenderers() {
  return sharingRenderers;
}
var _setupBasicPresses, setupBasicPresses_fn, _onResizeStaleDropper, _width, _height, _onResize, onResize_fn, _cachedRenderer, _cachedCanvas, _cachedDragTracker, _dragTracker, dragTracker_fn, _cachedCamera, _cachedOrbitControls, _disconnectionFunctions2, _experimentalNextRenderFinishedCallback, _scheduler, _a12;
var Twisty3DVantage = (_a12 = class extends ManagedCustomElement {
  constructor(model, scene, options) {
    super();
    __privateAdd(this, _setupBasicPresses);
    __privateAdd(this, _onResize);
    __privateAdd(this, _dragTracker);
    __privateAdd(this, _onResizeStaleDropper, void 0);
    __privateAdd(this, _width, void 0);
    __privateAdd(this, _height, void 0);
    __privateAdd(this, _cachedRenderer, void 0);
    __privateAdd(this, _cachedCanvas, void 0);
    __privateAdd(this, _cachedDragTracker, void 0);
    __privateAdd(this, _cachedCamera, void 0);
    __privateAdd(this, _cachedOrbitControls, void 0);
    __privateAdd(this, _disconnectionFunctions2, void 0);
    __privateAdd(this, _experimentalNextRenderFinishedCallback, void 0);
    __privateAdd(this, _scheduler, void 0);
    this.model = model;
    this.options = options;
    this.scene = null;
    this.stats = null;
    this.rendererIsShared = shareRenderer();
    this.loadingElement = null;
    __privateSet(this, _onResizeStaleDropper, new StaleDropper());
    __privateSet(this, _width, 0);
    __privateSet(this, _height, 0);
    __privateSet(this, _cachedRenderer, null);
    __privateSet(this, _cachedCanvas, null);
    __privateSet(this, _cachedDragTracker, null);
    __privateSet(this, _cachedCamera, null);
    __privateSet(this, _cachedOrbitControls, null);
    __privateSet(this, _disconnectionFunctions2, []);
    __privateSet(this, _experimentalNextRenderFinishedCallback, null);
    __privateSet(this, _scheduler, new RenderScheduler(this.render.bind(this)));
    this.scene = scene ?? null;
    this.loadingElement = this.addElement(document.createElement("div"));
    this.loadingElement.classList.add("loading");
    if (twistyDebugGlobals.showRenderStats) {
      this.stats = new Stats();
      this.stats.dom.style.position = "absolute";
      this.contentWrapper.appendChild(this.stats.dom);
    }
  }
  async connectedCallback() {
    this.addCSS(twisty3DVantageCSS);
    this.addElement((await this.canvasInfo()).canvas);
    __privateMethod(this, _onResize, onResize_fn).call(this);
    const observer = new ResizeObserver(__privateMethod(this, _onResize, onResize_fn).bind(this));
    observer.observe(this.contentWrapper);
    this.orbitControls();
    __privateMethod(this, _setupBasicPresses, setupBasicPresses_fn).call(this);
    this.scheduleRender();
  }
  async clearCanvas() {
    if (this.rendererIsShared) {
      const canvasInfo = await this.canvasInfo();
      canvasInfo.context.clearRect(0, 0, canvasInfo.canvas.width, canvasInfo.canvas.height);
    } else {
      const renderer = await this.renderer();
      const context = renderer.getContext();
      context.clear(context.COLOR_BUFFER_BIT);
    }
  }
  async renderer() {
    if (this.rendererIsShared) {
      throw new Error("renderer expected to be shared.");
    }
    return __privateGet(this, _cachedRenderer) ?? __privateSet(this, _cachedRenderer, newRenderer());
  }
  async canvasInfo() {
    return __privateGet(this, _cachedCanvas) ?? __privateSet(this, _cachedCanvas, (async () => {
      let canvas;
      if (this.rendererIsShared) {
        canvas = this.addElement(document.createElement("canvas"));
      } else {
        const renderer = await this.renderer();
        canvas = this.addElement(renderer.domElement);
      }
      this.loadingElement?.remove();
      const context = canvas.getContext("2d");
      return { canvas, context };
    })());
  }
  async camera() {
    return __privateGet(this, _cachedCamera) ?? __privateSet(this, _cachedCamera, (async () => {
      const camera = new (await THREEJS).PerspectiveCamera(20, 1, 0.1, 20);
      camera.position.copy(new (await THREEJS).Vector3(2, 4, 4).multiplyScalar(this.options?.backView ? -1 : 1));
      camera.lookAt(0, 0, 0);
      return camera;
    })());
  }
  async orbitControls() {
    return __privateGet(this, _cachedOrbitControls) ?? __privateSet(this, _cachedOrbitControls, (async () => {
      const orbitControls = new TwistyOrbitControls(this.model, !!this.options?.backView, (await this.canvasInfo()).canvas, await __privateMethod(this, _dragTracker, dragTracker_fn).call(this));
      if (this.model) {
        this.addListener(this.model.twistySceneModel.orbitCoordinates, async (orbitCoordinates) => {
          const camera = await this.camera();
          setCameraFromOrbitCoordinates(camera, orbitCoordinates, this.options?.backView);
          this.scheduleRender();
        });
      }
      return orbitControls;
    })());
  }
  addListener(prop, listener) {
    prop.addFreshListener(listener);
    __privateGet(this, _disconnectionFunctions2).push(() => {
      prop.removeFreshListener(listener);
    });
  }
  disconnect() {
    for (const fn of __privateGet(this, _disconnectionFunctions2)) {
      fn();
    }
    __privateSet(this, _disconnectionFunctions2, []);
  }
  experimentalNextRenderFinishedCallback(callback) {
    __privateSet(this, _experimentalNextRenderFinishedCallback, callback);
  }
  async render() {
    var _a13;
    if (!this.scene) {
      throw new Error("Attempted to render without a scene");
    }
    this.stats?.begin();
    const [scene, camera, canvas] = await Promise.all([
      this.scene.scene(),
      this.camera(),
      this.canvasInfo()
    ]);
    if (this.rendererIsShared) {
      renderPooled(__privateGet(this, _width), __privateGet(this, _height), canvas.canvas, scene, camera);
    } else {
      (await this.renderer()).render(scene, camera);
    }
    this.stats?.end();
    (_a13 = __privateGet(this, _experimentalNextRenderFinishedCallback)) == null ? void 0 : _a13.call(this);
    __privateSet(this, _experimentalNextRenderFinishedCallback, null);
  }
  scheduleRender() {
    __privateGet(this, _scheduler).requestAnimFrame();
  }
}, _setupBasicPresses = new WeakSet(), setupBasicPresses_fn = async function() {
  const dragTracker = await __privateMethod(this, _dragTracker, dragTracker_fn).call(this);
  dragTracker.addEventListener("press", async (e) => {
    const movePressInput = await this.model.twistySceneModel.movePressInput.get();
    if (movePressInput !== "basic") {
      return;
    }
    this.dispatchEvent(new CustomEvent("press", {
      detail: {
        pressInfo: e.detail,
        cameraPromise: this.camera()
      }
    }));
  });
}, _onResizeStaleDropper = new WeakMap(), _width = new WeakMap(), _height = new WeakMap(), _onResize = new WeakSet(), onResize_fn = async function() {
  const camera = await __privateGet(this, _onResizeStaleDropper).queue(this.camera());
  const w = this.contentWrapper.clientWidth;
  const h = this.contentWrapper.clientHeight;
  __privateSet(this, _width, w);
  __privateSet(this, _height, h);
  const off = 0;
  let yoff = 0;
  let excess = 0;
  if (h > w) {
    excess = h - w;
    yoff = -Math.floor(0.5 * excess);
  }
  camera.aspect = w / h;
  camera.setViewOffset(w, h - excess, off, yoff, w, h);
  camera.updateProjectionMatrix();
  this.clearCanvas();
  if (this.rendererIsShared) {
    const canvasInfo = await this.canvasInfo();
    canvasInfo.canvas.width = w * pixelRatio();
    canvasInfo.canvas.height = h * pixelRatio();
    canvasInfo.canvas.style.width = `${w.toString()}px`;
    canvasInfo.canvas.style.height = `${h.toString()}px`;
  } else {
    const renderer = await this.renderer();
    renderer.setSize(w, h, true);
  }
  this.scheduleRender();
}, _cachedRenderer = new WeakMap(), _cachedCanvas = new WeakMap(), _cachedDragTracker = new WeakMap(), _dragTracker = new WeakSet(), dragTracker_fn = async function() {
  return __privateGet(this, _cachedDragTracker) ?? __privateSet(this, _cachedDragTracker, (async () => {
    const dragTracker = new DragTracker((await this.canvasInfo()).canvas);
    this.model?.twistySceneModel.dragInput.addFreshListener((dragInputMode) => {
      let dragInputEnabled = false;
      switch (dragInputMode) {
        case "auto": {
          dragTracker.start();
          dragInputEnabled = true;
          break;
        }
        case "none": {
          dragTracker.stop();
          break;
        }
      }
      this.contentWrapper.classList.toggle("drag-input-enabled", dragInputEnabled);
    });
    return dragTracker;
  })());
}, _cachedCamera = new WeakMap(), _cachedOrbitControls = new WeakMap(), _disconnectionFunctions2 = new WeakMap(), _experimentalNextRenderFinishedCallback = new WeakMap(), _scheduler = new WeakMap(), _a12);
customElementsShim.define("twisty-3d-vantage", Twisty3DVantage);

export {
  getFaceletStickeringMask,
  getPieceStickeringMask,
  getPartialAppendOptionsForPuzzleSpecificSimplifyOptions,
  customPGPuzzleLoader,
  eventInfo,
  cube3x3x3,
  puzzles,
  StaleDropper,
  TwistyPropSource,
  SimpleTwistyPropSource,
  NO_VALUE,
  TwistyPropDerived,
  FreshListenerManager,
  RenderScheduler,
  hintFaceletStyles,
  HintFaceletProp,
  TAU,
  DEGREES_PER_RADIAN,
  HTMLElementShim,
  customElementsShim,
  CSSSource,
  ManagedCustomElement,
  proxy3D,
  THREEJS,
  rawRenderPooled,
  setCameraFromOrbitCoordinates,
  haveStartedSharingRenderers,
  Twisty3DVantage
};
